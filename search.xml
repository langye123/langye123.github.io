<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux手动安装nginx,JDK，redis,mysql</title>
      <link href="/2024/08/01/linx%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85nginx,JDK%EF%BC%8Credis,mysql/"/>
      <url>/2024/08/01/linx%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85nginx,JDK%EF%BC%8Credis,mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><ol><li>先下载相关的依赖 <code>yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel</code></li><li>访问nginx官网下载稳定版 nginx <code>https://nginx.org/en/download.html</code> 我自己已经下载过了直接传上去</li><li>user&#x2F;local下创建一个文件夹放nginx</li><li>解压文件 <code>tar -zxvf nginx-1.26.1.tar.gz</code> 会在当前目录创建一个文件名的文件夹<ul><li><code>tar</code>: 调用 <code>tar</code> 命令。<ul><li><code>-z</code>: 通过 Gzip 解压缩文件。</li><li><code>-x</code>: 解压缩文件。</li><li><code>-v</code>: 在解压缩过程中显示详细的文件列表（verbose）。</li><li><code>-f</code>: 后面跟上要解压缩的文件名。</li></ul></li></ul></li><li>自己解压的路径  <code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code><br>没有报错就继续运行 <code> make sudo make install</code> 完成配置  解压到那个地方 <code>/usr/local/nginx</code></li><li>启动nginx <code>sudo /usr/local/nginx/sbin/nginx </code></li><li>查看nginx 是否在运行 <code>ps aux | grep nginx </code></li></ol><h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><ol><li><p>同样自己先下载好安装包，上传到文件夹下面</p></li><li><p>解压后，记住绝对路径，vim打开 <code> vim /etc/profile</code> 把下面的输入进去，记住路径改成自己jdk的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/soft/jdk-17.0.12</span><br><span class="line">export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></li><li><p><code>source /etc/profile</code> 重新加载配置path</p></li><li><p><code>输入 java-version </code>查看配置</p></li></ol><h1 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h1><ol><li><p>同样自己先下载后，上传到文件夹下面<br>安装gcc环境 因为redis是c语言开发的 <code>yum install gcc c++ autoconf automake</code> 升级gcc环境</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   # 安装 SCL 源</span><br><span class="line">yum install -y centos-release-scl scl-utils-build</span><br><span class="line"># 安装 9 版本的 gcc、gcc-c++、gdb 工具链（toolchian）</span><br><span class="line">yum install -y devtoolset-9-toolchain</span><br><span class="line"># 临时覆盖系统原有的 gcc 引用</span><br><span class="line">scl enable devtoolset-9 bash</span><br></pre></td></tr></table></figure></li><li><p>解压后 cd到文件夹下面 <code> make &amp; make install</code> 执行命令编译一下 不指定安装目录会在默认安装 <code>user/local/bin/</code></p></li><li><p>修改配置文件 <code>vim redis.con</code></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">· bind 改为 * -::* （所有机器均可访问）</span><br><span class="line"></span><br><span class="line">    ·daemonize修改为yes （后台运行redis）</span><br><span class="line"></span><br><span class="line">    ·protected-mode 设置为no   （也就是关闭保护模式，否则只有bind指定的机器可访问，线上服务建议设置为yes）</span><br><span class="line">     require</span><br><span class="line"></span><br><span class="line">     requirepass *******  设置密码</span><br><span class="line">         </span><br></pre></td></tr></table></figure></li><li><p>如果上面3和4不行那就就，重新cd到redis目录下 <code>make</code>编译一下之后重新安装到指定目录 <code>make PREFIX=/usr/local/redis install</code><br><strong>make</strong>: 这是一个构建工具，用于根据 <code>Makefile</code> 文件中的说明进行编译和构建程序。在您编译 Redis 时，这个命令生成了可执行文件和其他必要的资源。</p><ul><li><p><strong>PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</strong>: 这是一个环境变量，它指定安装目标的前缀目录。在这个例子中，所有文件将被安装到 <code>/usr/local/redis</code> 目录。使用 <code>PREFIX</code> 变量允许您自定义安装路径。</p></li><li><p><strong>install</strong>: 这是一个 <code>Makefile</code> 中的指令，表示将编译生成的二进制文件和其他相关文件复制到指定的安装目录中。</p></li></ul><p>安装过程</p><p>当您运行这个命令时，它会执行以下操作：</p><ol><li>复制编译生成的 Redis 服务器和客户端二进制文件（如 <code>redis-server</code> 和 <code>redis-cli</code>）到 <code>/usr/local/redis/bin</code> 目录。</li><li>创建必要的目录结构，如 <code>/usr/local/redis/etc</code>（用于配置文件）和 <code>/usr/local/redis/data</code>（用于数据存储）等。</li><li>可能会安装一些额外的文档或示例文件。</li></ol></li><li><p>具体 <code>cat redis.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; &gt;&gt; conf/redis-6379.conf</code></p><ol><li><p><strong>cat redis.conf</strong>:</p><ul><li><code>cat</code> 命令用于显示文件内容。在这里，它显示了 <code>redis.conf</code> 配置文件的内容。</li></ul></li><li><p><strong>|</strong>:</p><ul><li>管道符号将前一个命令的输出传递给下一个命令。</li></ul></li><li><p><strong>grep -v “#”</strong>:</p><ul><li><code>grep</code> 命令用于搜索文本。选项 <code>-v</code> 表示反向匹配，即选取不包含 <code>#</code> 的行。</li><li>实际上，这一部分是用来过滤掉配置文件中的注释行（以 <code>#</code> 开头的行）。</li></ul></li><li><p><strong>grep -v “^$”</strong>:</p><ul><li>这个部分同样使用 <code>grep</code>，并通过选项 <code>-v</code> 过滤掉空行（即没有内容的行）。</li><li><code>^$</code> 是一个正则表达式，表示行的开始和结束之间没有任何字符。</li></ul></li><li><h2 id="conf-redis-6379-conf-操作符用于将输出附加到指定文件-conf-redis-6379-conf-中。如果该文件不存在，会创建一个新文件。-如果该文件已经存在，新的输出将被追加到文件末尾。"><a href="#conf-redis-6379-conf-操作符用于将输出附加到指定文件-conf-redis-6379-conf-中。如果该文件不存在，会创建一个新文件。-如果该文件已经存在，新的输出将被追加到文件末尾。" class="headerlink" title="&gt;&gt; conf&#x2F;redis-6379.conf:- &gt;&gt; 操作符用于将输出附加到指定文件 conf/redis-6379.conf 中。如果该文件不存在，会创建一个新文件。- 如果该文件已经存在，新的输出将被追加到文件末尾。"></a><strong>&gt;&gt; conf&#x2F;redis-6379.conf</strong>:<br>- <code>&gt;&gt;</code> 操作符用于将输出附加到指定文件 <code>conf/redis-6379.conf</code> 中。如果该文件不存在，会创建一个新文件。<br>- 如果该文件已经存在，新的输出将被追加到文件末尾。</h2><p>需要提前创建 <code>conf</code>文件夹 如果该文件夹不存在，命令会因找不到路径而失败，并不会自动创建文件夹。<code>mkdir conf</code></p></li></ol></li><li><p>启动指定加载配置文件 <code> redis-server conf/redis-6379.conf</code></p></li></ol><p><code>ps -ef|grep redis</code> 查看运行状态<br><code> kill -9 pid</code> 强制杀死</p><h1 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h1><p>抱歉 mysql 最终用控制面版安装的，<code>which mysql</code> 查看安装到那个地方了<br>进行接下来的配置</p><p>注意 ，这个地方以后将不会用centos 系统<br>建议也是下载之后安装到linx服务器中</p><p>如果非要安装下面是过程</p><ol><li><p>控制面板安装mysql</p></li><li><p><code>mkdir -p /www/server/data</code> 创建目录</p></li><li><p>更改目录权限 <code>chown -R mysql:mysql /www/server/data chmod -R 755 /www/server/data</code>  </p></li><li><p>查看 MySQL 服务状态<br>运行以下命令查看 MySQL 服务的详细状态：</p><p><code>systemctl status mysqld.service</code></p></li><li><p>查找 MySQL 的安装路径。通常，MySQL 的可执行文件位于 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin 或 &#x2F;usr&#x2F;bin 目录下。你可以使用以下命令查找：</p><p><code>find / -name mysqld</code></p><ol start="2"><li>添加 MySQL 安装路径到 PATH<br>找到 MySQL 安装路径后，将其添加到系统的 PATH 环境变量中。例如，如果 mysqld 位于 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin，你可以执行以下命令：</li></ol><p>export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin</p><p>为了使这个更改永久生效，可以将上述命令添加到你的 ~&#x2F;.bash_profile 文件中：<br><code>echo &#39;export PATH=$PATH:/www/server/mysql/bin&#39; &gt;&gt; ~/.bash_profile source ~/.bash_profile</code></p></li><li><p><code>mysqld --initialize --user=mysql --datadir=/www/server/data</code></p></li><li><p>手动下载 libaio RPM 包：<br>  <code> curl -O https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/libaio-0.3.109-13.el7.x86_64.rpm</code></p><p>安装 libaio RPM 包：<br><code>rpm -ivh libaio-0.3.109-13.el7.x86_64.rpm</code></p></li><li><p>再次尝试初始化 MySQL 数据目录： <code> mysqld --initialize --user=mysql --datadir=/www/server/data</code></p></li></ol><h3 id="上面的配置完成之后启动成功"><a href="#上面的配置完成之后启动成功" class="headerlink" title="上面的配置完成之后启动成功"></a>上面的配置完成之后启动成功</h3><ol><li><p>启动 MySQL 服务<br> <code>  systemctl start mysqld</code><br>停止Mysql服务<br>  <code> systemctl stop mysqld</code></p></li><li><p>检查 MySQL 服务状态<br>确保 MySQL 服务已成功启动：</p></li></ol><p><code>systemctl status mysqld</code></p><ol start="3"><li>使用临时密码登录 MySQL<br>使用生成的临时密码 <code>/oEE-wFuu5:j </code>登录 MySQL：</li></ol><p><code>mysql -u root -p</code></p><p>系统会提示你输入密码，输入临时密码即可。</p><ol start="4"><li><p>更改 root 用户密码<br>登录后，立即更改 root 用户的密码：</p><p>SQL</p><p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;;</code></p><p>创建用户：<br>SQL</p><p><code>create user &#39;stt&#39;@&#39;%&#39; identified by &#39;stt123456&#39;;</code><br>这条命令创建了一个名为 stt 的用户，密码为 stt123456。’%’ 表示该用户可以从任何主机连接到 MySQL 服务器。</p><p>设置权限：<br>SQL<br><code> grant all privileges on *.* to &#39;stt&#39;@&#39;%&#39;;</code><br>这条命令赋予 stt 用户对所有数据库和表的所有权限。*.* 表示所有数据库和所有表。</p><p>刷新权限：<br>SQL</p><p><code>flush privileges;</code></p></li><li><p>退出Mysql 命令行 <code>exit;</code></p></li></ol><h1 id="稻草项目上线"><a href="#稻草项目上线" class="headerlink" title="稻草项目上线"></a>稻草项目上线</h1><p><strong>因为是项目依赖所以在父项目中先构建依赖</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>然后在启动类当中再构建一下</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">warName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">warName</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cmd 到根目录下 <code>mvn clean package -Dmaven.test.skip=true</code> 打包成jar包</p><p>mvn clean: 清理项目，删除 target 目录中的所有文件。<br>package: 编译项目并打包成一个JAR文件。<br>-Dmaven.test.skip&#x3D;true: 跳过测试阶段，不运行单元测试。</p><p>控制器登录一下服务器</p><p><code>java -jar ./daocao_stater.jar</code> 运行一下 如果没有问题就 <code> nohup java -jar ./daocao_stater.jar &gt; output.log 2&gt;&amp;1 &amp;</code> 运行到后端，日志输出当前目录下<br>看看后端运行成功没<br>  <code>ps -ef | grep java</code></p><h2 id="前端打包"><a href="#前端打包" class="headerlink" title="前端打包"></a>前端打包</h2><p>打包的时候，把默认请求头，改一下路径，然后用nginx代理下，转发到本地请求</p><ol><li>cmd 到文件夹下面 <code>npm run build</code></li><li>去到nginx的conf文件夹下面把配置改一下</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen       <span class="number">80</span>;</span><br><span class="line">   server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.<span class="property">access</span>.<span class="property">log</span>  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /ssm/daocaoqianduan/dist;</span><br><span class="line">            try_files $uri $uri/ /index.<span class="property">html</span>;</span><br><span class="line">            index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         location /api/ &#123;</span><br><span class="line">            proxy_set_header <span class="title class_">Host</span> $http_host;</span><br><span class="line">            proxy_set_header X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span> $remote_addr;</span><br><span class="line">            proxy_set_header <span class="variable constant_">REMOTE</span>-<span class="variable constant_">HOST</span> $remote_addr;</span><br><span class="line">            proxy_set_header X-<span class="title class_">Forwarded</span>-<span class="title class_">For</span> $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass <span class="attr">http</span>:<span class="comment">//localhost:8091/;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="下面是快速启动的"><a href="#下面是快速启动的" class="headerlink" title="下面是快速启动的"></a>下面是快速启动的</h1><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx  ."></a>nginx  .</h2><p>启动nginx <code>sudo /usr/local/nginx/sbin/nginx</code><br>编辑nginx  <code>vim /usr/local/nginx/conf/nginx.conf</code><br>重启nginx <code>sudo /usr/local/nginx/sbin/nginx -s reload</code><br>查看nginx 是否在运行 <code>ps aux | grep nginx</code><br>查看占用端口的命令 <code>sudo lsof -i :80</code></p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>启动指定加载配置文件 <code> redis-server conf/redis-6379.conf</code>  注意先cd 到reids目录 <code>/usr/local/soft/redis-7.0.15</code></p><p><code>ps -ef|grep redis</code> 查看运行状态<br><code> kill -9 pid</code> 强制杀死</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ol><li><p>启动 MySQL 服务<br><code>  systemctl start mysqld</code><br>停止Mysql服务<br><code> systemctl stop mysqld</code></p></li><li><p>检查 MySQL 服务状态<br>确保 MySQL 服务已成功启动：</p></li></ol><p><code>systemctl status mysqld</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> 工具搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝塔控制面板常见问题总结</title>
      <link href="/2024/08/01/%E5%AE%9D%E5%A1%94%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2024/08/01/%E5%AE%9D%E5%A1%94%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="访问控制面板404"><a href="#访问控制面板404" class="headerlink" title="访问控制面板404"></a>访问控制面板404</h2><ol><li>执行 <code> bt 14</code></li><li>根据弹出的公网地址重新访问</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的cmd命令</title>
      <link href="/2024/07/19/%E5%B8%B8%E8%A7%81%E7%9A%84cmd%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/07/19/%E5%B8%B8%E8%A7%81%E7%9A%84cmd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="查看所有端口占用情况"><a href="#查看所有端口占用情况" class="headerlink" title="查看所有端口占用情况"></a>查看所有端口占用情况</h2><p><code>netstat -ano</code> 这将显示所有端口的占用情况，包括进程的 PID（进程标识符）</p><p>察看特定端口占用情况<br><code>netstat -ano | findstr :端口</code></p><h2 id="改变文件hash值"><a href="#改变文件hash值" class="headerlink" title="改变文件hash值"></a>改变文件hash值</h2><ol><li><code>certutil -hashfile 文件名.mp4 MD5</code>   查看文件的hash值</li><li><code>copy/b 1.mp4 +1.txt 强制.mp4</code> 注意顺序，放在前面的文件，会保留其内容，结束之后记得看能不能打开</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitBash相关问题</title>
      <link href="/2024/07/18/GitBash%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/18/GitBash%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前景导入"><a href="#前景导入" class="headerlink" title="前景导入"></a>前景导入</h2><ol><li>生成公钥  <code>$ ssh-keygen -t rsa -C “填邮箱地址</code> 具体可以看安装git的那一篇博客</li><li>查看公钥  <code>cat ~/.ssh/id_rsa.pub</code></li></ol><h2 id="上传到Gitee的情况"><a href="#上传到Gitee的情况" class="headerlink" title="上传到Gitee的情况"></a>上传到Gitee的情况</h2><ol><li>创建一个仓库，记得把自己的公钥添加进个人公钥里面，而不是仓库公钥里面，而且记住在个人设置里面不要添加隐藏自己的邮箱要不然提交不上去，。</li><li>具体如何上传可以看实战2后端——稻草人，上面有教程，这里只说一点，初始化之后记得<code>git add *</code> 添加所有项目，注意如果要重新传，记得清空一下仓库</li></ol><h2 id="重点gitignore"><a href="#重点gitignore" class="headerlink" title="重点gitignore"></a>重点gitignore</h2><h3 id="重点-gitignore"><a href="#重点-gitignore" class="headerlink" title="重点 .gitignore"></a>重点 <code>.gitignore</code></h3><h4 id="什么是-gitignore-文件？"><a href="#什么是-gitignore-文件？" class="headerlink" title="什么是 .gitignore 文件？"></a>什么是 <code>.gitignore</code> 文件？</h4><p><code>.gitignore</code> 文件用于告诉 Git 哪些文件或目录不需要被跟踪。它通过列出文件名或模式来忽略特定的文件或文件夹，从而保持代码库的整洁和高效。</p><h4 id="创建-gitignore-文件"><a href="#创建-gitignore-文件" class="headerlink" title="创建 .gitignore 文件"></a>创建 <code>.gitignore</code> 文件</h4><ol><li>在项目的根目录下创建一个名为 <code>.gitignore</code> 的文件。</li><li>使用任何文本编辑器打开该文件，并添加需要忽略的文件或目录的模式。</li></ol><h4 id="gitignore-文件的基本语法"><a href="#gitignore-文件的基本语法" class="headerlink" title=".gitignore 文件的基本语法"></a><code>.gitignore</code> 文件的基本语法</h4><ul><li><strong>注释</strong>：以 <code>#</code> 开头的行是注释。</li><li><strong>忽略文件</strong>：直接写文件名或模式。</li><li><strong>忽略目录</strong>：在目录名后加 <code>/</code>。</li><li><strong>通配符</strong>：<ul><li><code>*</code> 匹配零个或多个字符。</li><li><code>?</code> 匹配单个字符。</li><li><code>[abc]</code> 匹配方括号内的任意一个字符。</li><li><code>**</code> 匹配多级目录。</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li><p><strong>忽略单个文件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>忽略特定类型的所有文件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.log</span><br></pre></td></tr></table></figure></li><li><p><strong>忽略特定目录中的所有文件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs/*</span><br></pre></td></tr></table></figure></li><li><p><strong>忽略整个目录及其内容</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs/</span><br></pre></td></tr></table></figure></li><li><p><strong>使用排除模式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logs/*</span><br><span class="line">!logs/*.log</span><br><span class="line">这个规则设置会忽略`logs`目录下的所有文件，除了那些扩展名为`.log`的日志文件</span><br></pre></td></tr></table></figure></li></ol><h4 id="检查-gitignore-是否生效"><a href="#检查-gitignore-是否生效" class="headerlink" title="检查 .gitignore 是否生效"></a>检查 <code>.gitignore</code> 是否生效</h4><p>使用 Git Bash 可以检查 <code>.gitignore</code> 文件是否生效。以下是一些常用命令：</p><ol><li><p><strong>查看当前状态</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>运行此命令后，查看输出中是否包含 <code>.gitignore</code> 文件中列出的文件。如果没有包含，说明 <code>.gitignore</code> 文件生效。</p></li><li><p><strong>检查特定文件是否被忽略</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git check-ignore -v &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git check-ignore -v logs/debug.log</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot3注解相关问题</title>
      <link href="/2024/07/18/Springboot3%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/18/Springboot3%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Service注解"><a href="#Service注解" class="headerlink" title="Service注解"></a>Service注解</h2><h3 id="Service注解加在那个地方"><a href="#Service注解加在那个地方" class="headerlink" title="Service注解加在那个地方"></a>Service注解加在那个地方</h3><ol><li><p>加在实现类，而不是接口上</p><p>实例化 Bean：@Service 注解用于将类标识为 Spring 的服务组件，并将其实例化为 Spring 容器中的一个 Bean。<br><strong>由于接口不能被实例化，所以 @Service 注解应加在实现类上</strong><br>依赖注入：在使用依赖注入时，通常会通过接口类型注入实现类的实例。这样可以实现松耦合和更好的可测试性<br> <code>上面那句话的意思，虽然加在实现类但是你中注入的时候还是注入它的接口</code></p></li><li><p>错误理解 一个接口有多个实现类，而加在接口就可以，只需注入一个就可以调用所有实现这个接口的方法</p></li></ol><p>  将 @Service 注解加在接口上并不会使得所有实现类都自动成为 Spring 管理的 Bean。Spring 只会实例化那些被注解的具体类，而不是接口。</p><p>  如果一个接口有多个实现类，通常的做法是将 @Service 注解加在每个实现类上，然后在注入时使用 @Qualifier 注解来指定具体的实现类。<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">               // 接口</span><br><span class="line">public interface MyService &#123;</span><br><span class="line">    void performTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">               // 实现类1</span><br><span class="line">@Service</span><br><span class="line">@Qualifier(&quot;serviceImpl1&quot;)</span><br><span class="line">public class MyServiceImpl1 implements MyService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void performTask() &#123;</span><br><span class="line">                // 实现具体逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           / 实现类2</span><br><span class="line">@Service</span><br><span class="line">@Qualifier(&quot;serviceImpl2&quot;)</span><br><span class="line">public class MyServiceImpl2 implements MyService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void performTask() &#123;</span><br><span class="line">        // 实现具体逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           // 注入时指定具体实现类</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;serviceImpl1&quot;)</span><br><span class="line">private MyService myService;</span><br><span class="line"></span><br><span class="line"> ```  </span><br><span class="line">## MapperScan注解为什么有的加有的不加</span><br><span class="line">使用 @MapperScan 注解可以简化 MyBatis 项目的配置。它的主要作用是自动扫描指定包路径下的所有 Mapper 接口，并将它们注册到 Spring 容器中。</span><br><span class="line"></span><br><span class="line">这样，你就不需要在每个 Mapper 接口上手动添加 @Mapper 注解了12。</span><br><span class="line"></span><br><span class="line">如果你的项目中有多个 Mapper 接口，使用 @MapperScan 可以减少重复配置，简化代码</span><br><span class="line"></span><br><span class="line">## SpringBootApplication</span><br><span class="line">会扫描启动类，同目录下的所有包</span><br><span class="line">`@SpringBootApplication` 是 Spring Boot 提供的一个核心注解，用于简化 Spring Boot 应用的配置。它是一个组合注解，包含了以下三个注解¹²：</span><br><span class="line"></span><br><span class="line">1. **`@Configuration`**：标记一个类为配置类，类似于传统的 Spring 配置文件。</span><br><span class="line">2. **`@EnableAutoConfiguration`**：启用 Spring Boot 的自动配置机制，根据项目中的依赖自动配置 Spring 应用上下文。</span><br><span class="line">3. **`@ComponentScan`**：启用组件扫描，自动发现并注册 Spring 组件（如 `@Component`、`@Service`、`@Repository` 等）。</span><br><span class="line"></span><br><span class="line">使用 `@SpringBootApplication` 注解可以让你的主类成为 Spring Boot 应用的入口点。例如：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>@SpringBootApplication</code> 注解标记了 <code>MyApp</code> 类作为 Spring Boot 应用的入口。<code>SpringApplication.run()</code><br>方法会启动 Spring 应用上下文，进行自动配置和组件扫描</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
            <tag> springboot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战2_稻草人后端</title>
      <link href="/2024/07/17/%E5%AE%9E%E6%88%982%E5%90%8E%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BA/"/>
      <url>/2024/07/17/%E5%AE%9E%E6%88%982%E5%90%8E%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="引入Mysql不是有mysql，本地还是要安装mysql"><a href="#引入Mysql不是有mysql，本地还是要安装mysql" class="headerlink" title="引入Mysql不是有mysql，本地还是要安装mysql"></a>引入Mysql不是有mysql，本地还是要安装mysql</h2><h2 id="遇见了一个错误，不能很好跑起来SpringbootApplication"><a href="#遇见了一个错误，不能很好跑起来SpringbootApplication" class="headerlink" title="遇见了一个错误，不能很好跑起来SpringbootApplication"></a>遇见了一个错误，不能很好跑起来SpringbootApplication</h2><p>解决这个问题，或者可以用spring生成器进行操作。<br>下面是放在dependencyManagement中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">依赖项放在 dependencyManagement 部分中，这样做的好处是可以集中管理依赖项的版本，并在子模块中引用这些依赖项时不需要重复指定版本号。这种方式可以减少版本冲突和依赖管理的复杂性。</span><br><span class="line"></span><br><span class="line">以下是一些可能的原因，解释为什么这样做解决了你的问题：</span><br><span class="line"></span><br><span class="line">集中管理依赖版本：dependencyManagement 部分允许你在一个地方定义所有依赖项的版本，这样在子模块中引用这些依赖项时，不需要再指定版本号，减少了版本冲突的可能性。</span><br><span class="line">正确的依赖范围：将 spring-boot-dependencies 放在 dependencyManagement 中，并使用 import scope 是正确的做法。这确保了 Spring Boot 的依赖项版本管理能够正确应用到你的项目中。</span><br><span class="line">避免重复定义：通过 dependencyManagement，你可以避免在多个模块中重复定义相同的依赖项和版本号，这样可以减少错误和不一致性。</span><br><span class="line">传递依赖项：Maven 会自动处理传递依赖项，确保所有必要的库都被正确下载和包含在项目中。</span><br></pre></td></tr></table></figure><h2 id="idea插件"><a href="#idea插件" class="headerlink" title="idea插件"></a>idea插件</h2><p><code>CodeGlance pro: 代码缩略图</code><br><code>GenerateAllSetter 一键调用一个对象的所有的set方法,get方法等 在方法上生成两个对象的转换</code></p><h2 id="创建gitee仓库"><a href="#创建gitee仓库" class="headerlink" title="创建gitee仓库"></a>创建gitee仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">快速设置— 如果你知道该怎么操作，直接使用下面的地址</span><br><span class="line"> </span><br><span class="line">git@gitee.com:langye521/daocao_study.git</span><br><span class="line">我们强烈建议所有的git仓库都有一个README, LICENSE, .gitignore文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">简易的命令行入门教程:</span><br><span class="line">Git 全局设置:</span><br><span class="line"></span><br><span class="line">            git config --global user.name &quot;langye521&quot;</span><br><span class="line">            git config --global user.email &quot;2401004776@qq.com&quot;</span><br><span class="line">创建 git 仓库:</span><br><span class="line"></span><br><span class="line">            mkdir daocao_study</span><br><span class="line">            cd daocao_study</span><br><span class="line">            git init </span><br><span class="line">            touch README.md</span><br><span class="line">            git add README.md</span><br><span class="line">            git commit -m &quot;first commit&quot;</span><br><span class="line">            git remote add origin git@gitee.com:langye521/daocao_study.git</span><br><span class="line">            git push -u origin &quot;master&quot;</span><br><span class="line">已有仓库?</span><br><span class="line"></span><br><span class="line">            cd existing_git_repo</span><br><span class="line">            git remote add origin git@gitee.com:langye521/daocao_study.git</span><br><span class="line">            git push -u origin &quot;master&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实体类Serializable-接口的主要目"><a href="#实体类Serializable-接口的主要目" class="headerlink" title="实体类Serializable 接口的主要目"></a>实体类Serializable 接口的主要目</h2><p>在 Java 中，实体类实现 <code>Serializable</code> 接口的主要目的是为了将对象转换为字节序列，以便在网络上传输或在不同系统之间进行持久化存储。以下是一些具体的原因：</p><h3 id="1-网络传输"><a href="#1-网络传输" class="headerlink" title="1. 网络传输"></a>1. 网络传输</h3><p>当需要在网络上发送对象数据时，例如在客户端和服务器之间进行通信，通过序列化可以将对象转换为字节流，在网络上传输效率高，并且确保数据的完整性¹²。</p><h3 id="2-持久化存储"><a href="#2-持久化存储" class="headerlink" title="2. 持久化存储"></a>2. 持久化存储</h3><p>当需要将对象永久保存到文件系统、数据库或缓存中时，可以使用序列化将对象保存为字节流，这样可以方便地进行存储和读取²。</p><h3 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3. 进程间通信"></a>3. 进程间通信</h3><p>在多进程或分布式系统中，不同进程或节点之间需要传递数据，通过序列化可以简化数据传递的过程²。</p><h3 id="4-对象复制"><a href="#4-对象复制" class="headerlink" title="4. 对象复制"></a>4. 对象复制</h3><p>有时候需要复制对象，通过序列化和反序列化可以快速实现对象的深拷贝²。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>要实现序列化接口，只需在类的定义中添加 <code>implements Serializable</code> 即可。需要注意的是，为了成功序列化一个对象，其所有成员变量也必须是可序列化的。如果有成员变量不可序列化，可以使用 <code>transient</code> 关键字来标记它们，表示在序列化过程中忽略这些成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String transientField; <span class="comment">// This field won&#x27;t be serialized</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors, getters, setters, and other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现 <code>Serializable</code> 接口，Java 对象可以被序列化，从而方便地在网络上传输和进行持久化存储¹²³。<br><strong>总的来说应该是为Stream吧</strong></p><h2 id="Service接口层的实现类如果这么写"><a href="#Service接口层的实现类如果这么写" class="headerlink" title="Service接口层的实现类如果这么写"></a>Service接口层的实现类如果这么写</h2><p><code>public class UmsRoleServiceimpl extends ServiceImpl&lt;UmsRoleMapper, UmsRole&gt; implements UmsRoleService &#123; &#125;</code></p><p><strong>这个  Service的实现类将会获得数据库的操作权限</strong></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServiceImpl&lt;UmsRoleMapper, UmsRole&gt; 是 MyBatis-Plus 提供的一个通用服务实现类。通过继承这个类，UmsRoleServiceimpl 类自动获得了许多通用的 CRUD（创建、读取、更新、删除）操作方法。</span><br><span class="line"> </span><br><span class="line">  泛型参数</span><br><span class="line">    UmsRoleMapper 是一个 Mapper 接口，定义了与数据库交互的方法。</span><br><span class="line">    UmsRole 是一个实体类，代表数据库中的一张表。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hutool"><a href="#hutool" class="headerlink" title="hutool"></a>hutool</h2><p>总的来说，他是为了封装响应给前端页面。内置的工具</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;cn.hutool&lt;/groupId&gt;        &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cn.hutool:hutool-all 是一个非常全面的 Java 工具类库，旨在通过封装静态方法来简化开发过程，提高工作效率。它包含了许多常用的工具类，涵盖了从字符串处理、日期处理到文件操作、HTTP 请求等多个方面12。</span><br><span class="line"></span><br><span class="line">以下是 Hutool 的一些主要功能：</span><br><span class="line"></span><br><span class="line">字符串处理：提供了丰富的字符串操作方法，如截取、替换、格式化等。</span><br><span class="line">日期处理：简化了日期和时间的操作，包括日期格式化、解析、计算等。</span><br><span class="line">文件操作：支持文件的读写、复制、删除等操作。</span><br><span class="line">HTTP 请求：提供了简洁的 HTTP 客户端，方便进行网络请求。</span><br><span class="line">JSON 解析：支持 JSON 的解析和生成，简化了 JSON 数据的处理。</span><br><span class="line">加密解密：提供了多种加密解密算法，方便进行数据安全处理</span><br></pre></td></tr></table></figure><h2 id="注意这个项目把模块分成了好几个子模块"><a href="#注意这个项目把模块分成了好几个子模块" class="headerlink" title="注意这个项目把模块分成了好几个子模块"></a>注意这个项目把模块分成了好几个子模块</h2><ol><li>他有父亲模块，打包成pom，里面定义依赖版本</li><li>common ：定义一些最基础，通用的工具类或者公用的类，比如lombok，hutoo</li><li>support    核心配置模块，做一些项目中引入的第三方组件的配置，比如：MyBatisPlus、 SpringSecurity、Redis、支付，support依赖common模块</li><li>auth  这里面是认证模块，</li><li>stater 里面定义springboot启动器模块</li></ol><h3 id="下面是他们之间的调用关系-注意调用，只能调用被被依赖的模块，不能调用依赖的。"><a href="#下面是他们之间的调用关系-注意调用，只能调用被被依赖的模块，不能调用依赖的。" class="headerlink" title="下面是他们之间的调用关系,注意调用，只能调用被被依赖的模块，不能调用依赖的。"></a>下面是他们之间的调用关系,注意调用，只能调用被被依赖的模块，不能调用依赖的。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">common是最基础的模块--------》被support模块引用------》support被其他的业务模块引用-------》</span><br><span class="line">auth/sysuser/引用----------》被starter模块引用</span><br></pre></td></tr></table></figure><h2 id="mybatis——plus的自动填充功能"><a href="#mybatis——plus的自动填充功能" class="headerlink" title="mybatis——plus的自动填充功能"></a>mybatis——plus的自动填充功能</h2><ol><li>用于在插入或更新数据时自动填充某些字段，如创建时间、更新时间等。以下是如何使用这一功能的详细说明。</li><li>自动填充功能通过实现 com.baomidou.mybatisplus.core.handlers.MetaObjectHandler 接口来实现。</li><li>在实体类上注解字段那个需要填充<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    它使用的注解是@TableField(fill = FieldFill.INSERT)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private String createTime;</span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.UPDATE)</span><br><span class="line">    private String updateTime;</span><br><span class="line"></span><br><span class="line">    // 其他字段...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>确保你的 MyMetaObjectHandler 类被 Spring 管理，可以通过 @Component 或 @Bean 注解来实现<br>详情请看mybatisplus的官方文档</li></ol><h2 id="Servlce层一旦实现Iservice"><a href="#Servlce层一旦实现Iservice" class="headerlink" title="Servlce层一旦实现Iservice"></a>Servlce层一旦实现Iservice</h2><p>就有了CRUD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save(T entity)：保存实体。</span><br><span class="line">removeById(Serializable id)：根据 ID 删除实体。</span><br><span class="line">getById(Serializable id)：根据 ID 获取实体。</span><br><span class="line">list()：获取所有实体列表。</span><br></pre></td></tr></table></figure><p>首先看两段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface UmsSysUserService extends IService&lt;UmsSysUser&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UmsMenuServiceimpl extends ServiceImpl&lt;UmsMenuMapper, UmsMenu&gt; implements UmsMenuService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细解释<br>接口继承 IService</p><p>UmsMenuService 接口 继承了 IService<UmsMenu>，这意味着它继承了 IService 中定义的所有抽象方法（CRUD 操作）。<br>这些抽象方法包括 save、removeById、getById、list 等。</p><p>实现类继承 ServiceImpl</p><p>UmsMenuServiceImpl 类 继承了 ServiceImpl&lt;UmsMenuMapper, UmsMenu&gt;，并实现了 UmsMenuService 接口。<br>ServiceImpl 是 MyBatis-Plus 提供的一个通用实现类，它已经实现了 IService 中的所有方法。因此，UmsMenuServiceImpl 通过继承 ServiceImpl，自动获得了这些方法的实现。</p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot3 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战2前端_稻草人vue3</title>
      <link href="/2024/07/17/%E5%AE%9E%E6%88%982%E5%89%8D%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BAvue3/"/>
      <url>/2024/07/17/%E5%AE%9E%E6%88%982%E5%89%8D%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BAvue3/</url>
      
        <content type="html"><![CDATA[<h2 id="导入环境，初始化一个vue3项目"><a href="#导入环境，初始化一个vue3项目" class="headerlink" title="导入环境，初始化一个vue3项目"></a>导入环境，初始化一个vue3项目</h2><p>利用控制台，注意不是idea控制台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 10.0.22631.3737]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">D:\cheng shi xi tong\idea\ssm\实战springboot3\实战3_稻草人\daocao_study&gt;npm create vue</span><br><span class="line">Need to install the following packages:</span><br><span class="line">create-vue@3.10.4</span><br><span class="line">Ok to proceed? (y) y</span><br><span class="line"></span><br><span class="line">Vue.js - The Progressive JavaScript Framework</span><br><span class="line"></span><br><span class="line">√ 请输入项目名称： ... daocao_admin_page</span><br><span class="line">√ 是否使用 TypeScript 语法？ ... 否 / 是</span><br><span class="line">√ 是否启用 JSX 支持？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vue Router 进行单页面应用开发？ ... 否 / 是</span><br><span class="line">√ 是否引入 Pinia 用于状态管理？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vitest 用于单元测试？ ... 否 / 是</span><br><span class="line">√ 是否要引入一款端到端（End to End）测试工具？ » 不需要</span><br><span class="line">√ 是否引入 ESLint 用于代码质量检测？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vue DevTools 7 扩展用于调试? (试验阶段) ... 否 / 是</span><br><span class="line"></span><br><span class="line">正在初始化项目 D:\cheng shi xi tong\idea\ssm\实战springboot3\实战3_稻草人\daocao_study\daocao_admin_page...</span><br><span class="line"></span><br><span class="line">项目初始化完成，可执行以下命令：</span><br><span class="line"></span><br><span class="line">  cd daocao_admin_page</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前端VsCode插件导入安装"><a href="#前端VsCode插件导入安装" class="headerlink" title="前端VsCode插件导入安装"></a>前端VsCode插件导入安装</h2><ol><li>Auto Close Tag：自动为HTML&#x2F;XML标签添加闭合标签1。</li><li>Vue VSCode Snippets：提供Vue.js开发的代码片段，提升开发效率2。</li><li>Vue Peek：允许在Vue单文件组件中快速跳转或预览定义3。</li><li>Image preview：在代码编辑器中预览图像4。</li></ol><h2 id="这个项目同样用到了Element-plus"><a href="#这个项目同样用到了Element-plus" class="headerlink" title="这个项目同样用到了Element -plus"></a>这个项目同样用到了Element -plus</h2><ol><li><code>npm install element-plus --save</code>  安装element -plus<br>   具体可以看用idea写前端vue里面的element —plus</li><li>第二步，按需导入，一样 官网快速开始，安装两个插件<code>npm install -D unplugin-vue-components unplugin-auto-import</code></li><li>第三步，在vite.config.js里面设置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> AutoImport(&#123;</span><br><span class="line">resolvers: [ElementPlusResolver()],</span><br><span class="line">  &#125;),</span><br><span class="line">  Components(&#123;</span><br><span class="line">    resolvers: [ElementPlusResolver()],</span><br><span class="line">  &#125;),</span><br></pre></td></tr></table></figure></li></ol><h2 id="el-button-放在el-form里面还是外面"><a href="#el-button-放在el-form里面还是外面" class="headerlink" title="el-button 放在el-form里面还是外面"></a>el-button 放在el-form里面还是外面</h2><ol><li>放在 el-form 里面： 如果按钮是表单的一部分，比如提交按钮或重置按钮，通常会放在 el-form 里面。这样可以确保按钮与表单的布局和样式一致。</li><li>放在 el-form 外面： 如果按钮的功能与表单无关，或者你希望按钮在表单外部显示，可以将按钮放在 el-form 外面</li></ol><h2 id="cursor-pointer-css悬停改变指针为小手"><a href="#cursor-pointer-css悬停改变指针为小手" class="headerlink" title="cursor: pointer css悬停改变指针为小手"></a>cursor: pointer css悬停改变指针为小手</h2><h2 id="click"><a href="#click" class="headerlink" title="@click"></a>@click</h2><p>如果要传参数，记得加上（），如果不传参，可写可不写<br><code>@click=&quot;handerlogin&quot;</code></p><p>再scrip里面定义参数的时候注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const handerlogin=()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function handerlogin()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两则的区别</p><ol><li><p><strong>函数表达式</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handerlogin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是使用ES6箭头函数表达式定义的函数。在这种情况下，<code>handerlogin</code>被赋予了一个常量（const）来存储函数。这种方式创建的函数是<em>匿名函数</em>，因为函数本身没有名字。</p></li><li><p><strong>函数声明</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handerlogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是常规的函数声明方式，直接使用<code>function</code>关键字来给函数命名。这种情况下，<code>handerlogin</code>是一个具名函数。</p></li></ol><p>从使用上来说两则没有什么区别</p><h2 id="前端封装工具类"><a href="#前端封装工具类" class="headerlink" title="前端封装工具类"></a>前端封装工具类</h2><ol><li>安装  <code>npm install axios</code></li><li>在vue工程中创建一个文件夹用来存放相对应的，request封装类</li><li><pre><code class="javascript">   const requset=axios.create(&#123;              //配置请求地址 baseURL:&#39;http://localhost:8091&#39;,                 //用于配置请求接口跨域 withCredentials: false, timeout: 30000//超时时间，单位毫秒 &#125;)   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   在这里创建 request，配置默认请求地址，开启跨域，注意这个时候还不知道究竟那个是正确的默认，注意分辨。</span><br><span class="line">4. ``//设置请求头为json，和编码格式</span><br><span class="line">   axios.defaults.headers[&#x27;Content-Type&#x27;]=&#x27;application/json;chatset=utf-8&#x27;``</span><br><span class="line">5. 配置请求拦截器</span><br><span class="line">   ```javascript</span><br><span class="line">      requset.interceptors.request.use((config)=&gt;&#123;</span><br><span class="line">            // 在请求头添加token，判断是否需要发送token</span><br><span class="line">               // ToDD token 应该从pinia中获取</span><br><span class="line">   if(token)&#123;</span><br><span class="line">   config.headers[&#x27;Daocao-token&#x27;]=token</span><br><span class="line">   &#125;</span><br><span class="line">   return config</span><br><span class="line">   &#125;,(error)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">        // 发生异常</span><br><span class="line">        console.log(&#x27;请求异常====》》&#x27;+error)</span><br><span class="line">        return Promise.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">request.interceptors.request.use((config) =&gt; &#123; ... &#125;, (error) =&gt; &#123; ... &#125;):</span><br><span class="line">这是 Axios 的请求拦截器。use 方法接受两个参数：一个是请求成功时的回调函数，另一个是请求失败时的回调函数。</span><br><span class="line">(config) =&gt; &#123; ... &#125;:</span><br><span class="line">这是请求成功时的回调函数。config 是当前请求的配置对象。</span><br><span class="line">添加 token 到请求头：</span><br><span class="line">if(token)&#123; config.headers[&#x27;Daocao-token&#x27;] = token &#125;：</span><br><span class="line">这段代码检查是否存在 token，如果存在，则将其添加到请求头中，键名为 Daocao-token。</span><br><span class="line">token 应该从 Pinia（一个状态管理库）中获取。</span><br><span class="line">返回配置对象：</span><br><span class="line">return config：</span><br><span class="line">返回修改后的配置对象，以便请求继续进行。</span><br><span class="line">处理请求异常：</span><br><span class="line">(error) =&gt; &#123; ... &#125;：</span><br><span class="line">这是请求失败时的回调函数。</span><br><span class="line">console.log(&#x27;请求异常====》》&#x27; + error)：</span><br><span class="line">打印请求异常信息到控制台。</span><br><span class="line">return Promise.reject(error)：</span><br><span class="line">返回一个被拒绝的 Promise，以便在调用链中处理错误。</span><br></pre></td></tr></table></figure></code></pre></li><li>配置响应请求头<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//配置响应拦截器</span></span><br><span class="line">requset.<span class="property">interceptors</span>.<span class="title function_">response</span>((<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 判断响应码，和后端的返回数据</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> &#123;msg,code&#125; = response.<span class="property">data</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;code====&gt;&#x27;</span>,code,<span class="string">&#x27;msg====&gt;&#x27;</span>,msg)</span><br><span class="line"> <span class="keyword">if</span>(code==<span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> response;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(code==<span class="number">200</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> response</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(code==<span class="number">500</span>)&#123;</span><br><span class="line">         <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;服务端异常&#x27;</span>)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(code==<span class="number">401</span>)&#123;</span><br><span class="line">     <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;没有操作权限&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(code==<span class="number">403</span>)&#123;</span><br><span class="line">     <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;未登录&#x27;</span>)</span><br><span class="line">     <span class="comment">//需要重新登录，并且清楚pinia中的数据，sessionStorage中</span></span><br><span class="line">     <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line">     router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span>  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(msg)</span><br><span class="line"></span><br><span class="line">   &#125;,<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&quot;error=====&gt;&quot;</span>,error)</span><br><span class="line">   <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line">   router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   ))</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> requset;</span><br></pre></td></tr></table></figure></li></ol><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setToken</span>(<span class="params">tokenkey,token</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(tokenkey,token)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>export：这是 ES6 模块语法，用于导出函数，使其可以在其他模块中被导入和使用。</p><p>function setToken(tokenkey, token)：定义了一个名为 setToken 的函数，接收两个参数 tokenkey 和 token。</p><p>sessionStorage.setItem(tokenkey, token)：使用 sessionStorage 的 setItem 方法，将 token 存储在 sessionStorage 中，键名为 tokenkey</p><h2 id="注意前端通过判断响应是否成功来检验"><a href="#注意前端通过判断响应是否成功来检验" class="headerlink" title="注意前端通过判断响应是否成功来检验"></a>注意前端通过判断响应是否成功来检验</h2><p>如果配置有响应拦截器，首先会现在响应拦截器里判断状态码，如果是200返回原来的请求进行下面的操作。</p><h2 id="配置菜单"><a href="#配置菜单" class="headerlink" title="配置菜单"></a>配置菜单</h2><p><strong>前言，当你看到这个地方的时候只有一件事，那就是后端已经两天没写了，不是不想写，我的奶奶，太厉害了我完全听不懂</strong><br>本来前端我也不想写了，没办法。还是写一下吧：</p><h3 id="菜单模块采用，inside-侧边栏"><a href="#菜单模块采用，inside-侧边栏" class="headerlink" title="菜单模块采用，inside 侧边栏"></a>菜单模块采用，inside 侧边栏</h3><h2 id="pinia-持久化"><a href="#pinia-持久化" class="headerlink" title="pinia 持久化"></a>pinia 持久化</h2><ol><li>用于避免导致刷新造成数据丢失<br><code>npm install pinia-plugin-persistedstate</code></li><li>main.js 引入一下插件  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import piniaPluginPersistedstate from &#x27;pinia-plugin-persistedstate&#x27;;</span><br><span class="line"></span><br><span class="line">const pinia = createPinia();</span><br><span class="line"></span><br><span class="line">pinia.use(piniaPluginPersistedstate);</span><br><span class="line"></span><br><span class="line">app.use(pinia);</span><br></pre></td></tr></table></figure></li><li>状态管理上那个存入持久化   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         persist: &#123;</span><br><span class="line">    enabled: true,</span><br><span class="line">    strategies: [</span><br><span class="line">        &#123;</span><br><span class="line">            key: &#x27;useMenu&#x27;,</span><br><span class="line">            storage: localStorage,</span><br><span class="line">            paths: [&#x27;menuList&#x27;, &#x27;routerList&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义svg"><a href="#自定义svg" class="headerlink" title="自定义svg"></a>自定义svg</h2><p> 导入依赖 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install fast-glob</span><br><span class="line"> npm install vite-plugin-svg-icons</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh公钥更改，删除，添加</title>
      <link href="/2024/07/14/ssh%E5%85%AC%E9%92%A5%E6%9B%B4%E6%94%B9%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E6%B7%BB%E5%8A%A0/"/>
      <url>/2024/07/14/ssh%E5%85%AC%E9%92%A5%E6%9B%B4%E6%94%B9%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E6%B7%BB%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>登录服务器：使用 SSH 客户端登录到服务器。<br><code>ssh username@server_ip_address</code></p><p>找到公钥文件：在服务器上，SSH 公钥通常存储在用户的 .ssh 目录下。<br><code>cd ~/.ssh</code></p><p>查看公钥文件：列出当前存在的公钥文件。<br><code>ls</code><br>指出当前文件夹下的所有文件或文件夹<br>这个地方会显示公钥列表<br>打开 authorized_keys 文件：<br><code>vim ~/.ssh/authorized_keys</code></p><p>进入插入模式：在 Vim 中，按 i 键进入插入模式。<br>删除不需要的公钥：使用箭头键移动光标到需要删除的公钥行，然后按 dd 删除整行。<br>保存并退出：<br>按 Esc 键退出插入模式。<br>输入 :wq 保存并退出 Vim。<br>重新启动 SSH 服务（可选）：如果你修改了 authorized_keys 文件，可以通过重启 SSH 服务使更改生效。<br><code>sudo service ssh restart</code></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客问题汇总</title>
      <link href="/2024/07/14/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2024/07/14/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ol><li>标签问题，感觉标签或者分类不是特别合适，换一下，导致部署出来旧的分类或者标签还在</li></ol><p>解决： 去public，文件夹下把对应的旧的文件夹删掉。记住用 hexo clean 多试几遍<br>2. 公钥问题登不上去，github，把博客迁移到自己的服务器上，想着githun上面也不能荒废，想着往上面再传一下，发现传不上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub                    查看自己的公钥看看是不是变了，结果没有变</span><br><span class="line">ssh -T -ai ~/.ssh/id_rsa git@github.com  查看公钥被github上面哪一个用户或者仓库使用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人梯子搭建指南</title>
      <link href="/2024/07/13/%E4%B8%AA%E4%BA%BA%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/07/13/%E4%B8%AA%E4%BA%BA%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="第一次shadworks"><a href="#第一次shadworks" class="headerlink" title="第一次shadworks"></a>第一次shadworks</h2><h2 id="前景导入"><a href="#前景导入" class="headerlink" title="前景导入"></a>前景导入</h2><p>身为一个优秀的程序员，只会去网上用其他人的机场，是不是有点low,还不方便，害怕他随时跑路，本文记录一下自己梯子过程</p><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><p>1.不要用阿里云香港服务器，本人第一次用阿里云香港服务器，运行了一小会，正在怯怯自喜，直接ip被封了，还好是弹性公网IP</p><p>2.网上随便找一个，香港服务器，注意辨别，这里就不在推荐</p><h2 id="直接上才艺"><a href="#直接上才艺" class="headerlink" title="直接上才艺"></a>直接上才艺</h2><ol><li><p>**安装 <code>python-pip</code> 和 <code>shadowsocks</code>**：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-pip</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure></li><li><p>**创建并编辑 <code>/etc/shadowsocks.json</code>**：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure></li><li><p><strong>将格式化后的内容粘贴到 <code>shadowsocks.json</code> 文件中</strong>：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">8388</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dd531322!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动 <code>shadowsocks</code> 服务</strong>：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></li><li><p><strong>使用客户端连接</strong>：</p><p> 确保 U 盘内的 <code>shadowsocks</code> 客户端版本为 4.0.9，并输入相应的配置信息：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server: 0.0.0.0</span><br><span class="line">Server Port: 8388</span><br><span class="line">Local Address: 127.0.0.1</span><br><span class="line">Local Port: 1080</span><br><span class="line">Password: Dd531322!</span><br><span class="line">Encryption Method: aes-256-cfb</span><br></pre></td></tr></table></figure><p> 配置完成后即可通过客户端使用代理服务。</p></li><li><p><strong>防火墙设置</strong>：</p><p> 关闭本地防火墙并打开云防火墙，以确保服务可以正常连接：</p><p> 停止并禁用防火墙：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p> 请根据云防火墙的文档配置相应的规则，确保 TCP 端口 8388 (服务器端口) 和 1080 (本地代理端口) 开放。</p></li></ol><p>注意：关闭防火墙可能会造成安全风险，请根据实际情况调整防火墙规则，确保只有被信任的流量被允许通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 常见的问题总结</span><br><span class="line">使用`ps -ef | grep ssserver`查看所有ssserver进程，可以查看shadowswork是否运行</span><br><span class="line"></span><br><span class="line">使用`sudo kill -9 29644`强制终结shadowswork 使用了Linux中的&quot;sudo&quot;来提升权限，并使用&quot;kill&quot;命令终止进程，&quot;-9&quot;是一个信号，表示强制终止该进程。&quot;29644&quot;是要终止的进程的进程号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用` ps aux`查看所有进程信息</span><br><span class="line"></span><br><span class="line">使用`firewall-cmd --zone=public --list-ports`查看防火墙所有打开的端口</span><br><span class="line"></span><br><span class="line">使用`sudo iptables -L -v -n` 显示当前配置的所有防火墙规则，包括哪些端口和IP地址被允许或阻止</span><br><span class="line"></span><br><span class="line">另外进行`vim`操作的时候，按i键，进入编辑模式，按esc键退出编辑模式，按`:wq`保存并退出，按`:q`键退出不保存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分隔，"><a href="#分隔，" class="headerlink" title="分隔，"></a>分隔，</h2><h2 id="下面是第二次的vpn"><a href="#下面是第二次的vpn" class="headerlink" title="下面是第二次的vpn"></a>下面是第二次的vpn</h2><h2 id="第二次v2ray"><a href="#第二次v2ray" class="headerlink" title="第二次v2ray"></a>第二次v2ray</h2><p><strong>这一次的服务器用的是森屿云</strong><br><code>sudo su</code>  切换成管理员账户</p><p><code>bash &lt;(curl -s -L https://git.io/v2ray.sh)</code>安装vr2y.</p><p>下面是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Time consumed: 14 Minute!</span><br><span class="line">[root@ser800490606008 ~]# sudo su</span><br><span class="line">[root@ser800490606008 ~]#</span><br><span class="line">[root@ser800490606008 ~]# bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br><span class="line"></span><br><span class="line">........... V2Ray script by 233boy ..........</span><br><span class="line"></span><br><span class="line">13:10:30) 开始安装...</span><br><span class="line">13:10:30) 下载 V2Ray 脚本 &gt; https://github.com/233boy/v2ray/releases/latest/download/code.zip</span><br><span class="line">13:10:30) 下载 jq &gt; https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64</span><br><span class="line">13:10:30) 下载 V2Ray &gt; https://github.com/v2fly/v2ray-core/releases/latest/download/v2ray-linux-64.zip</span><br><span class="line">13:11:21) 生成配置文件...</span><br><span class="line"></span><br><span class="line">使用协议: VMess-TCP</span><br><span class="line">-------------- VMess-TCP-7255.json -------------</span><br><span class="line">协议 (protocol)         = vmess</span><br><span class="line">地址 (address)          = IP地址</span><br><span class="line">端口 (port)             = 7255</span><br><span class="line">用户ID (id)             = 59e404c0-2fa9-45af-8a52-e6781712f949</span><br><span class="line">传输协议 (network)      = tcp</span><br><span class="line">伪装类型 (type)         = none</span><br><span class="line"></span><br><span class="line">警告! 首次安装请查看脚本帮助文档: https://233boy.com/v2ray/v2ray-script/</span><br><span class="line"></span><br><span class="line">------------- 链接 (URL) -------------</span><br><span class="line">vmess://eyJ2IjoyLCJwcyI6IjIzM2JveS10Y3AtMjAzLjkxLjczLjE0MiIsImFkZCI6IjIwMy45MS43My4xNDIiLCJwb3J0IjoiNzI1NSIsImlkIjoiNTllNDA0YzAtMmZhOS00NWFmLThhNTItZTY3ODE3MTJmOTQ5IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwicGF0aCI6IiJ9</span><br><span class="line">------------- END -------------</span><br><span class="line">关注(tg): https://t.me/tg2333</span><br><span class="line">文档(doc): https://233boy.com/v2ray/v2ray-script/</span><br><span class="line">推广(ads): 机场推荐(V2Ray services): https://getjms.com/</span><br></pre></td></tr></table></figure><h2 id="注意系统是centos的命令-yum"><a href="#注意系统是centos的命令-yum" class="headerlink" title="注意系统是centos的命令 yum"></a>注意系统是centos的命令 yum</h2><p>安装系统后记得命令更新<br>更新软件包列表：<br><code>sudo yum update</code></p><p>&#96;sudo su</p><p>bash &lt;(curl -s -L <a href="https://git.io/v2ray.sh)%60">https://git.io/v2ray.sh)`</a></p><h2 id="记得把v2ray的命令放在路径当中"><a href="#记得把v2ray的命令放在路径当中" class="headerlink" title="记得把v2ray的命令放在路径当中"></a>记得把v2ray的命令放在路径当中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@ser800490606008 ~]# echo $PATH</span><br><span class="line">/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">[root@ser800490606008 ~]#  export PATH=$PATH:/usr/local/bin</span><br><span class="line">[root@ser800490606008 ~]# v2ray help</span><br><span class="line">V2Ray script v4.21 by 233boy</span><br><span class="line">Usage: v2ray [options]... [args]...</span><br><span class="line"></span><br><span class="line">基本:</span><br><span class="line">   v, version                                      显示当前版本</span><br><span class="line">   ip                                              返回当前主机的 IP</span><br><span class="line">   get-port                                        返回一个可用的端口</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就能用<code>v2ray</code>的命令了</p><h3 id="更改端口-v2ray-change-tcp-port-8389"><a href="#更改端口-v2ray-change-tcp-port-8389" class="headerlink" title="更改端口 v2ray change tcp port 8389"></a>更改端口 v2ray change tcp port 8389</h3><p>输入命令<code>v2ray change tcp port 端口</code> 更改端口不过记得进配置文件看看生效没有<br>输入命令<code>vim /etc/v2ray/config.json</code> 编辑配置文件</p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>查看防火墙<code>firewall-cmd --zone=public --list-ports</code></p><p>打开防火墙端口<code>firewall-cmd --zone=public --add-port=8389/tcp --permanent</code></p><p>重新加载防火墙配置<code>firewall-cmd --reload</code></p><h2 id="测试主机带宽"><a href="#测试主机带宽" class="headerlink" title="测试主机带宽"></a>测试主机带宽</h2><p>使用 <code>iperf3</code> 测试带宽非常简单。以下是基本步骤：</p><ol><li><p><strong>安装 iperf3</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install iperf3  <span class="comment"># 对于 CentOS 系统</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在服务器端启动 iperf3</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure><p>这将在默认端口（5201）上启动 iperf3 服务器。</p></li><li><p><strong>在客户端运行测试</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c server_address</span><br></pre></td></tr></table></figure><p>将 <code>server_address</code> 替换为服务器的 IP 地址或主机名。</p></li><li><p><strong>查看结果</strong>：<br>客户端会显示测试结果，包括带宽、丢包率等信息。</p></li></ol><p>例如，如果服务器的 IP 地址是 <code>192.168.1.1</code>，您可以在客户端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c 192.168.1.1</span><br></pre></td></tr></table></figure><p>这样，您就可以测量客户端和服务器之间的带宽了。如果需要更多高级选项，可以使用 <code>iperf3 -h</code> 查看帮助信息¹。</p><h1 id="第三次-山海云"><a href="#第三次-山海云" class="headerlink" title="第三次 山海云"></a>第三次 山海云</h1><p>注意在第二个项目的地址中使用<code>bash &lt;(curl -s -L https://git.io/v2ray.sh)</code>会造成，静默，跟随重定向。记得辨别</p><ul><li><p><code>-L</code>：跟随重定向。如果 URL 被重定向到另一个位置，这个选项会使 <code>curl</code> 继续请求新的 URL。</p></li><li><p><code>-s</code>：静默模式，不输出进度条和错误信息。<br>新地址 <code>bash &lt;(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh) </code><br>前置工作安装 </p></li><li><p>更新 <code>sudo yum update</code></p></li><li><p>安装vim <code>yum install vim</code></p></li></ul><h2 id="新问题，服务器没网"><a href="#新问题，服务器没网" class="headerlink" title="新问题，服务器没网"></a>新问题，服务器没网</h2><ol><li><code>sudo iptables -L -n</code> 查看防火墙所有规则，</li><li><code>sudo iptables -A INPUT -p icmp -j ACCEPT</code> 允许所有icmp流量进入</li></ol><h3 id="直接禁用防火墙，再开启"><a href="#直接禁用防火墙，再开启" class="headerlink" title="直接禁用防火墙，再开启"></a>直接禁用防火墙，再开启</h3><p>直接禁用防火墙，再开始，来测试是不是防火墙的原因<br><code>sudo systemctl stop firewalld</code> 禁用防火墙<br><code>sudo systemctl start firewalld</code>开启防火墙<br><strong>注意可能是端口的问题自定义安全组的时候注意</strong></p><h3 id="结局，重启把服务器，重装系统，安全组端口默认"><a href="#结局，重启把服务器，重装系统，安全组端口默认" class="headerlink" title="结局，重启把服务器，重装系统，安全组端口默认"></a>结局，重启把服务器，重装系统，安全组端口默认</h3><h2 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: **,</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;clients&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;id&quot;: &quot;e*****-e170-4c1e-97a8-8b2bfb3ac249&quot;,</span><br><span class="line">            &quot;alterId&quot;: 64,</span><br><span class="line">            &quot;security&quot;: &quot;aes-256-gcm&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;tcp&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inbounds:</span><br><span class="line">          这是一个数组，包含所有入站连接的配置。每个入站连接代表一个监听端口，V2Ray会在这些端口上接收数据。</span><br><span class="line">port: 8389</span><br><span class="line">          这是V2Ray监听的端口号。客户端需要连接到这个端口才能使用V2Ray服务。</span><br><span class="line">protocol: “vmess”</span><br><span class="line">           这是使用的协议类型。VMess是V2Ray的主要协议之一，用于加密和传输数据。</span><br><span class="line">settings:</span><br><span class="line">clients:         这是一个数组，包含所有允许连接到此入站的客户端配置。</span><br><span class="line">id: “eff2c845-e170-4c1e-97a8-8b2bfb3ac249”</span><br><span class="line">            这是客户端的UUID，用于唯一标识客户端。每个客户端需要一个唯一的UUID。</span><br><span class="line">alterId: 64</span><br><span class="line">              这是VMess协议的备用ID，用于增加安全性。</span><br><span class="line">security: “aes-256-gcm”</span><br><span class="line">            这是加密方式，使用AES-256-GCM进行数据加密。</span><br><span class="line">streamSettings:</span><br><span class="line">network: “tcp”</span><br><span class="line">              这是传输层协议，设置为TCP。可以根据需要更改为其他协议，如WebSocket（ws）。</span><br><span class="line">outbounds:</span><br><span class="line">                 这是一个数组，包含所有出站连接的配置。每个出站连接代表一个目标服务器，V2Ray会将数据发送到这些服务器。</span><br><span class="line">protocol: “freedom”</span><br><span class="line">                这是使用的协议类型。Freedom协议表示直接将数据发送到目标服务器，不进行任何代理。</span><br><span class="line">settings: &#123;&#125;</span><br><span class="line">              这是协议的具体设置。对于Freedom协议，通常不需要额外的设置，因此这里是一个空对象。</span><br></pre></td></tr></table></figure><h3 id="获取ssl证书"><a href="#获取ssl证书" class="headerlink" title="获取ssl证书"></a>获取ssl证书</h3><p>你可以使用 Let’s Encrypt 获取免费的 SSL 证书。首先，安装 Certbot：</p><p><code>sudo apt install certbot python3-certbot-nginx </code><br>然后，获取证书：</p><p>sudo certbot –nginx -d yourdomain.com<br>注意上面是错误的你的nginx安装，不在默认所以要用下面的命令<br><code>sudo certbot --nginx -d abc.langye.xyz --nginx-server-root /www/server/nginx/conf </code></p><p>但是系统不一样，需要用这个命令<br><code>sudo yum install certbot python2-certbot-nginx</code></p><p>现在已经成功了，</p><p>查看证书状态<br><code>sudo certbot certificates</code><br>续期证书<br><code>sudo certbot renew</code><br>自动续期证书<br><code>sudo certbot renew --dry-run</code><br>模拟测试程而不实际更改现有证书，帮助您验证配置是否正常。<br><code>sudo certbot renew --dry-run</code></p><h5 id="进阶版配置"><a href="#进阶版配置" class="headerlink" title="进阶版配置"></a>进阶版配置</h5><p>v2ray里面的配置是<br>注意里面的要更改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 8389,</span><br><span class="line">      &quot;listen&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;clients&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;id&quot;: &quot;*****-e170-4c1e-97a8-8b*****249&quot;,</span><br><span class="line">            &quot;alterId&quot;: 64,</span><br><span class="line">            &quot;security&quot;: &quot;aes-256-gcm&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;ws&quot;,</span><br><span class="line">        &quot;wsSettings&quot;: &#123;</span><br><span class="line">          &quot;path&quot;: &quot;/ray&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx里面的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name abc.langye.xyz;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/*******/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/abc.langye.xyz/privkey.pem;</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    location /ray &#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http://127.0.0.1:****;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 Nginx：<br><code>sudo /etc/init.d/nginx start</code></p><p>重启 Nginx：<br><code>sudo /etc/init.d/nginx restart</code></p><p>重新加载 Nginx 配置：<br><code>sudo /etc/init.d/nginx reload</code></p><p>停止 Nginx：<br><code>sudo /etc/init.d/nginx stop</code><br>打开nginx的配置文件<br><code>vi /www/server/nginx/conf/nginx.conf</code></p><p>启动服务 <code>systemctl start v2ray</code><br>重新启动 <code>systemctl restart v2ray</code><br>查看是否运行 <code>systemctl status v2ray</code><br>进入进行编辑<code>vim /usr/local/etc/v2ray/config.json</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迁移自己博客，从github到自己的服务器</title>
      <link href="/2024/07/13/%E8%BF%81%E7%A7%BBgithup%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/07/13/%E8%BF%81%E7%A7%BBgithup%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>前提自己系统是centox，登录到自己的服务器上，创建一个新的用户，<code>sudo adduser boke</code></p><ol><li>在服务器上安装必要的软件：<br>安装 Git 和 Nginx：<br><code>sudo apt install git</code><br>  <code>sudo apt install nginx</code><br><strong>注意在第二步的时候自己配置nginx完全不行，用的宝塔控制页面进行安装的，最后成功了</strong></li><li>配置 Nginx：<br>修改 Nginx 的默认配置文件（通常位于 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default），将博客文件放到 &#x2F;var&#x2F;www&#x2F;html 目录下。<br>注意：我的nginx在 <code>www/server/nginx/conf</code><br>打开命令配置<code>sudo vi /www/server/nginx/conf/nginx.conf</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在 http 块中添加一个新的 server 块来配置你的博客目录 /var/www/blog。你可以在 http 块的末尾添加以下内容：</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 自己的ip或者域名;</span><br><span class="line"></span><br><span class="line">    root /var/www/blog;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log /www/wwwlogs/yourblog_access.log;</span><br><span class="line">    error_log /www/wwwlogs/yourblog_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server 块是 Nginx 配置文件中的一个部分，用于定义不同的虚拟主机配置。每个 server 块可以配置一个独立的站点或服务。你现有的配置中已经有一个 server 块用于 phpmyadmin，我们需要添加另一个 server 块来配置你的博客站点。</span><br><span class="line"></span><br><span class="line">为什么需要多个 server 块？</span><br><span class="line">不同的服务：每个 server 块可以配置不同的服务。例如，一个用于 phpmyadmin，另一个用于你的博客。</span><br><span class="line">不同的域名或端口：每个 server 块可以监听不同的域名或端口。例如，一个监听 phpmyadmin 的端口 888，另一个监听你的博客的端口 80。</span><br><span class="line">独立配置：每个 server 块可以有独立的配置，例如根目录、日志文件、错误页面等。</span><br></pre></td></tr></table></figure><p>   重新加载 Nginx 配置：<br>   <code>sudo service nginx reload</code><br>3. 创建 Git 裸库：<br>   在服务器上创建一个 Git 裸库，用于保存博客文件：<br>   cd ~<br>   git init –bare blog.git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. `cd ~`: 这个命令表示切换到用户的家目录（`~` 是用户的主目录的简写），也就是登录用户默认的起始位置。</span><br><span class="line"></span><br><span class="line">`git init --bare blog.git`: 这是初始化一个新的 Git 仓库。`git init` 是创建一个新的 Git 项目的基本命令，而 `--bare` 参数意味着创建的是一个“裸”仓库，也称为轻量级仓库。这种类型的仓库不包含工作目录，主要用于远程存储库，</span><br><span class="line">如 GitHub、GitLab 等。`blog.git` 是你想要创建的 Git 仓库的名称，用于存放你的博客项目的版本控制信息。</span><br></pre></td></tr></table></figure><ol start="4"><li>配置 Git Hooks：<br>使用 Git 的 post-receive 钩子自动将最新内容同步到网站根目录：<br><code>vim ~/blog.git/hooks/post-receive</code><br>在文件中添加以下内容：<br>#!&#x2F;bin&#x2F;sh<br>git –work-tree&#x3D;&#x2F;var&#x2F;www&#x2F;html –git-dir&#x3D;~&#x2F;blog.git checkout -f<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=/var/www/blog --git-dir=/home/your_username/blog.git checkout -f</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. **`git --work-tree=/var/www/blog`**: 这部分指定 Git 的工作目录（Working Directory）为 `/var/www/blog`。这意味着所有与 Git 相关的文件操作都会在这个目录下进行。</span><br><span class="line"></span><br><span class="line">2. **`--git-dir=/home/boke/blog.git`**: 这个选项指出 Git 的仓库目录（Repository Directory）在用户 `boke` 的主目录下，即 `/home/boke/blog.git`。这通常指的是仓库的元数据（比如 `.git` 文件夹）存储的位置。</span><br><span class="line"></span><br><span class="line">3. **`checkout -f`**: 这个命令用于将工作目录 `/var/www/blog` 切换到与 `~/blog.git` 仓库关联的某个分支，或者强制性地恢复到特定的提交。`-f` 参数意味着如果存在未提交的更改，会丢弃这些更改以获取仓库的最新状态。</span><br><span class="line"></span><br><span class="line">整体来说，这个脚本的作用是将 `/var/www/blog` 目录的内容更新到与 `~/blog.git` 仓库中的最新提交或特定分支状态，通常用于远程仓库的自动化部署或同步。需要注意的是，如果 `/var/www/blog` 中有未提交的本地更改，使用 `-f` 参数可能会丢失这些更改，所以在使用时要确保没有意外的数据冲突。</span><br></pre></td></tr></table></figure>保存并赋予执行权限：</li></ol><p>  <code> chmod +x ~/blog.git/hooks/post-receive</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在这个上下文中，`~/blog.git/hooks/post-receive` 是一个位于 `hooks` 目录下的文件，通常在 Git 仓库中，`post-receive` 钩子文件是用来在接收远程仓库的推送时自动执行的脚本。`+x` 操作会赋予这个文件执行权限，使得系统允许其他用户（不仅仅是拥有者）可以通过运行这个文件来执行其中的命令。</span><br><span class="line"></span><br><span class="line">如果你之前编辑了 `post-receive` 文件并且想要使其能够在接收到远程推送时自动运行，那么设置执行权限是必要的。因为 Git 自动调用钩子文件，如果没有执行权限，Git 就无法运行这个脚本来完成相应的操作，比如更新服务器上的文件、触发构建等。</span><br></pre></td></tr></table></figure><p><strong>注意刚开始我又重新设置了一个角色，导致上一个命令不能正确赋予权限，我又重新到管理员的账号，执行了这个命令，注意把用户命令也加上<code>chmod +x /home/your_username/blog.git/hooks/post-receive </code></strong><br>5. 配置本地 Hexo 部署：<br>   打开 Hexo 博客根目录下的 _config.yml 文件，找到 deploy 部分并修改：<br>   deploy:<br>   type: git<br>   repository: ssh:&#x2F;&#x2F;user@your_server_ip:~&#x2F;blog.git<br>   branch: master<br>   执行以下命令将博客部署到服务器：<br>注意命令的用户名，和服务器地址要改。<br>   hexo clean<br>   hexo generate<br>   hexo deploy<br>6. 设置免密码登录：<br>   在本地生成 SSH 密钥对（如果还没有）：<br>   <code>ssh-keygen -t rsa</code><br>   将公钥上传到服务器：<br>  <code> ssh-copy-id user@your_server_ip</code><br>检查用户名公钥<br>   <code>cat ~/.ssh/authorized_keys</code></p><p>注意上传成功之后要在放行一下ssh规则</p><p><strong>这个地方部署ssl证书也就是tls证书</strong></p><p>首先找到安装nginx的默认目录可以用<code>nginx -t</code><br>当然对于你来说，你已经知道路径在哪，第一创建一个存放ssl证书的key和pem的地方，你存放的地方为<code>/www/server/nginx/conf</code><br>然后打开<code>sudo vi /www/server/nginx/conf/nginx.conf</code>进行编辑添加下面<br>内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line"></span><br><span class="line">    root /var/www/blog;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/cert/langye.xyz.pem;</span><br><span class="line">    ssl_certificate_key /path/to/cert/langye.xyz.key;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log /www/wwwlogs/yourblog_access.log;</span><br><span class="line">    error_log /www/wwwlogs/yourblog_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将端口钻发到443端口https路径<br>下面是详细解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nginx</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#### 解释：</span><br><span class="line">- `listen 80;`：告诉Nginx监听服务器的80端口，即默认的HTTP端口。</span><br><span class="line">- `server_name langye.xyz;`：指定服务器的域名为`langye.xyz`。</span><br><span class="line">- `return 301 https://$host$request_uri;`：这个指令会把所有通过HTTP发过来的请求重定向（301重定向）到对应的HTTPS地址。301状态码表示永久重定向。</span><br><span class="line"></span><br><span class="line">这个部分的配置主要是确保任何访问`http://langye.xyz`的请求都被安全地重定向到`https://langye.xyz`，让访问更加安全。</span><br><span class="line"></span><br><span class="line">### 第二段：</span><br><span class="line">```nginx</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line"></span><br><span class="line">    root /var/www/blog;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/cert/langye.xyz.pem;  ssl证书</span><br><span class="line">    ssl_certificate_key /path/to/cert/langye.xyz.key; 密钥</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log /www/wwwlogs/yourblog_access.log;</span><br><span class="line">    error_log /www/wwwlogs/yourblog_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>listen 443 ssl;</code>：告诉Nginx监听服务器的443端口，开启SSL（即HTTPS）。</li><li><code>server_name langye.xyz;</code>：指定服务器的域名为<code>langye.xyz</code>。</li><li><code>root /var/www/blog;</code>：设置网站的根目录为<code>/var/www/blog</code>，即静态文件的位置。</li><li><code>index index.html index.htm;</code>：指定默认的索引文件为<code>index.html</code>或者<code>index.htm</code>，如果访问的是目录，它会寻找这些文件来显示。</li></ul><h5 id="SSL配置："><a href="#SSL配置：" class="headerlink" title="SSL配置："></a>SSL配置：</h5><ul><li><code>ssl_certificate /path/to/cert/langye.xyz.pem;</code>：指定SSL证书文件的位置。</li><li><code>ssl_certificate_key /path/to/cert/langye.xyz.key;</code>：指定SSL证书密钥文件的位置。</li><li><code>ssl_protocols TLSv1.2 TLSv1.3;</code>：指定允许的SSL&#x2F;TLS协议版本。这里设置了TLS 1.2和TLS 1.3。</li><li><code>ssl_ciphers HIGH:!aNULL:!MD5;</code>：指定使用的加密算法。这一行过滤掉了一些低强度和不安全的算法。</li></ul><h5 id="Location配置："><a href="#Location配置：" class="headerlink" title="Location配置："></a>Location配置：</h5><ul><li><code>location / &#123; try_files $uri $uri/ =404; &#125;</code>：这个指令尝试找到请求的文件，如果找不到就返回404错误页面。<code>$&#123;uri&#125;</code>代表请求的URI，例如<code>/index.html</code>。<code>$uri/</code>代表目录，如果都找不到返回404。</li></ul><h5 id="日志配置："><a href="#日志配置：" class="headerlink" title="日志配置："></a>日志配置：</h5><ul><li><code>access_log /www/wwwlogs/yourblog_access.log;</code>：指定访问日志存放的位置。</li><li><code>error_log /www/wwwlogs/yourblog_error.log;</code>：指定错误日志存放的位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>打开 SSH 配置文件：<br>在终端中输入以下命令打开文件：<br>sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</li></ul><p>查找配置项：<br>在 vim 中，按 Esc 键进入命令模式，然后输入 &#x2F;PubkeyAuthentication 并按 Enter 键查找 PubkeyAuthentication 配置项。<br>确保该行未被注释（行首没有 #），并且设置为 yes：<br>PubkeyAuthentication yes</p><p>同样的方法查找 AuthorizedKeysFile 配置项，确保其设置为：<br>AuthorizedKeysFile .ssh&#x2F;authorized_keys</p><p>保存并退出：<br>按 Esc 键进入命令模式，然后输入 :wq 并按 Enter 键保存并退出 vim。<br>重启 SSH 服务：<br>修改配置文件后，需要重启 SSH 服务以使更改生效：<br>sudo systemctl restart sshd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">之后就成功了注意隐藏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`# cat /etc/passwd` 检查现在linx中所有用户</span><br><span class="line">`sudo passwd boke` 给boke设置密码</span><br><span class="line">`su - boke` 切换用户</span><br><span class="line">`sudo yum install git` 使用使用root用户或sudo命令安装</span><br><span class="line">`ps -ef | grep nginx`通过查看进程列表来确认 Nginx 是否在运行</span><br><span class="line">`sudo visudo` 系统级别的配置文件,可以用来添加权限</span><br><span class="line">`sudo chown -R boke:boke /var/www/blog`  这个命令用于改变 `/var/www/blog` 和其所有子目录及其内容的所有者（owner）和组所有者（group）。`-R` 参数表示递归（recursive），所以这个操作会应用于整个目录树。`boke:boke` 是指将所有文件和子目录的所有权更改为 `boke` 用户和 `boke` 组</span><br><span class="line">如何挂你nginx</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动 Nginx：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</p><p>重启 Nginx：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx restart</p><p>重新加载 Nginx 配置：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx reload</p><p>停止 Nginx：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx stop</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实战项目2</title>
      <link href="/2024/07/05/SpringBoot%E5%AE%9E%E6%88%98/"/>
      <url>/2024/07/05/SpringBoot%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Fastjson和ResponseBody区别"><a href="#Fastjson和ResponseBody区别" class="headerlink" title="Fastjson和ResponseBody区别"></a>Fastjson和ResponseBody区别</h1><p>现在的理解为fastjson和ResponseBody都是在springBoot实战里面将后端数据转换为json数据，他们的具体区别为ResponseBody为springmvc提供的<br>而fastjson是基于java库转换为json数据的。<br>一下是详细解释</p><ol><li><p><strong>Spring MVC 的 @ResponseBody</strong>：</p><ul><li>当你在 Spring MVC 控制器方法上使用 <code>@ResponseBody</code> 时，Spring 自动处理了将方法的返回值转换为 HTTP 响应体的过程。</li><li>它并不直接涉及具体的 JSON 序列化库，但通常会配合像 Jackson、Gson 或 Fastjson 这样的库来完成对象到 JSON 的转换。</li><li><code>@ResponseBody</code> 是一种约定，它告诉 Spring 不要尝试渲染视图，而是直接返回响应体。</li></ul></li><li><p><strong>Fastjson</strong>：</p><ul><li>Fastjson 是一个独立的 JSON 序列化&#x2F;反序列化库，用于将 Java 对象转换为 JSON 字符串或从 JSON 字符串反序列化为 Java 对象。</li><li>在没有 <code>@ResponseBody</code> 的情况下，你可以单独使用 Fastjson 来序列化 Java 对象，或者在 Spring MVC 中手动配置序列化器。</li></ul></li></ol><h2 id="字符编码的问题"><a href="#字符编码的问题" class="headerlink" title="字符编码的问题"></a>字符编码的问题</h2><p>  在实战中编码格式不对，中文导致浏览器无法识别，乱码 直接上</p><p> <strong>结论</strong><br>直接返回请求让浏览器识别utf-8格式，<code>response.setContentType(&quot;application/json;charset=UTF-8&quot;)</code></p><p>并且让响应数据格式也为utf-8<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code></p><p><strong>区别</strong></p><p>响应头编码 (Content-Type)：</p><p>作用：Content-Type 响应头告诉浏览器或客户端服务器返回的数据类型和字符编码。<br>示例：application&#x2F;json;charset&#x3D;UTF-8 表示返回的数据是 JSON 格式，并且使用 UTF-8 编码。<br>重要性：确保浏览器知道如何正确解析和显示返回的数据。</p><p>字符编码 (Character Encoding)：</p><p>作用：response.setCharacterEncoding(“UTF-8”) 设置了服务器在生成响应时使用的字符编码。<br>重要性：确保服务器在写入响应数据时使用正确的编码，特别是对于包含非 ASCII 字符（如中文）的数据。</p><p>两者结合直接无敌 utf-8</p><h2 id="mybatis写sql语句两种方法"><a href="#mybatis写sql语句两种方法" class="headerlink" title="mybatis写sql语句两种方法"></a>mybatis写sql语句两种方法</h2><p><strong>第一种</strong> 直接写在Mapper接口里面的，这个直接在接口上加上<code>@Mapper</code>的并且直接在方法上写上@Select或者其他CRUD的<br>直接是在本类上写sql语句，</p><p><strong>第二种</strong> 在抽象类写具体的方法名，它的实现在resource里相同的三层架构，对应一个接口，一个xml文件在里面写具体的sql语句<br>使得我们更加专注与sql语句的编写</p><p>接下来是相同的具体的优缺点详细解释</p><ul><li><strong>第一种使用注解编写SQL语句</strong></li></ul><p>优点：</p><p>简洁明了：直接在接口方法上编写SQL语句，代码量少，结构清晰。<br>方便维护：对于简单的SQL语句，使用注解可以减少文件数量，方便维护。<br>快速开发：适合快速开发和原型设计，减少了配置文件的编写时间。</p><p>缺点：</p><p>复杂SQL不便：对于复杂的SQL语句，注解方式不够直观，难以维护和调试。<br>灵活性差：注解方式在处理动态SQL时不如XML灵活。<br>可读性差：当SQL语句较长时，嵌入在代码中会影响代码的可读性。</p><ul><li><strong>第二种使用XML文件编写SQL语句</strong></li></ul><p>优点：</p><p>灵活性高：XML文件支持动态SQL，使用<if>、<choose>等标签可以方便地构建复杂的SQL语句。<br>分离关注点：将SQL语句与Java代码分离，增强了代码的可读性和可维护性。<br>易于调试：SQL语句独立于Java代码，便于调试和优化。</p><p>缺点：</p><p>配置繁琐：需要额外的XML配置文件，增加了项目的复杂度。<br>维护成本高：对于简单的SQL语句，使用XML文件显得过于复杂，维护成本较高。<br>开发效率低：编写和维护XML文件需要更多的时间和精力，不如注解方式高效</p><h2 id="在这个新的实战里大量用到了security"><a href="#在这个新的实战里大量用到了security" class="headerlink" title="在这个新的实战里大量用到了security"></a>在这个新的实战里大量用到了<code>security</code></h2><p>它的目的进行加密对密码,并且有一个</p><p><code>UserDetails</code>用来封装用来封装用户登录时所需的身份信息。这个接口或类定义了认证过程中需要获取的一些核心用户属性，以便进行用户验证和授权。</p><p><code>   &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;</code></p><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>如上文所说，我承认自己有点错误，它不仅是单单一个类，他是一个框架接下来看看官方的解释</p><h5 id="Spring-Security-是-Spring-家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。"><a href="#Spring-Security-是-Spring-家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。" class="headerlink" title="Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。"></a>Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。</h5><p> 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p><p>​ 一般Web应用的需要进行认证和授权。</p><p>​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</p><p>​ 授权：经过认证后判断当前用户是否有权限进行某个操作<br>咋一看，是不是特别很厉害，一开始小瞧它了</p><h2 id="牛逼的事来了，登录界面的-记住我"><a href="#牛逼的事来了，登录界面的-记住我" class="headerlink" title="牛逼的事来了，登录界面的 记住我"></a>牛逼的事来了，登录界面的 记住我</h2><p>首先，导入spring data jdbc ,然后 </p><p><code>@Autowired     DataSource dataSource;</code></p><p>好像引入了其目的它在 Spring Security 中用于“记住我”功能的持久化存储<br>&#96; @Bean</p><pre><code>public PersistentTokenRepository tokenRepository()&#123;    JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl();    jdbcTokenRepository.setDataSource(dataSource);    jdbcTokenRepository.setCreateTableOnStartup(true);    return jdbcTokenRepository;&#125;`</code></pre><p>  ** 注意上面的代码这段代码是用来配置一个 <code>PersistentTokenRepository</code> 实例的，它在 Spring Security 中用于“记住我”功能的持久化存储。具体来说：</p><ol><li><strong>创建 <code>JdbcTokenRepositoryImpl</code> 实例</strong>：<code>JdbcTokenRepositoryImpl</code> 是 <code>PersistentTokenRepository</code> 的一个实现类，用于将令牌存储在数据库中。</li><li><strong>设置数据源</strong>：通过 <code>jdbcTokenRepository.setDataSource(dataSource);</code> 将数据源注入到 <code>JdbcTokenRepositoryImpl</code> 中，这样它就可以访问数据库。</li><li><strong>创建表</strong>：<code>jdbcTokenRepository.setCreateTableOnStartup(true);</code> 指定在应用启动时自动创建所需的数据库表。</li></ol><p>这样配置后，Spring Security 会在用户选择“记住我”功能时，将相关的令牌信息存储在数据库中，而不是仅仅保存在内存中¹²。</p><p>这段代码配置了 Spring Security 的“记住我”功能，具体功能如下：</p><ol><li>**<code>.rememberMe()</code>**：启用“记住我”功能。</li><li>**<code>.rememberMeParameter(&quot;remember&quot;)</code>**：指定表单中用于“记住我”功能的参数名称为 <code>remember</code>。</li><li>**<code>.tokenRepository(this.tokenRepository())</code>**：设置令牌存储库为之前配置的 <code>JdbcTokenRepositoryImpl</code>，用于将令牌存储在数据库中。</li><li>**<code>.tokenValiditySeconds(3600*24)</code>**：设置令牌的有效期为 24 小时（3600 秒 * 24）。</li></ol><p>结合之前的 <code>tokenRepository</code> 方法，这段代码的作用是：</p><ul><li>当用户在登录时选择“记住我”选项时，Spring Security 会生成一个持久化的令牌，并将其存储在数据库中。</li><li>该令牌会被发送到用户的浏览器，并存储在 cookie 中。</li><li>在用户关闭浏览器并重新打开时，Spring Security 会根据该令牌自动验证用户身份，免去重新登录的步骤¹².</li></ul><p>这样配置后，用户在选择“记住我”功能后，即使关闭浏览器，也能在 24 小时内自动登录。</p><h3 id="它创建了一个表"><a href="#它创建了一个表" class="headerlink" title="它创建了一个表"></a>它创建了一个表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JdbcTokenRepositoryImpl 使用提供的数据源将令牌插入数据库。</span><br><span class="line">插入使用的 SQL 查询通常如下：</span><br><span class="line">SQL</span><br><span class="line"></span><br><span class="line">INSERT INTO persistent_logins (username, series, token, last_used) VALUES (?, ?, ?, ?)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="利用spring框架-mail-和自己的邮箱实现注册邮箱的功能"><a href="#利用spring框架-mail-和自己的邮箱实现注册邮箱的功能" class="headerlink" title="利用spring框架 mail 和自己的邮箱实现注册邮箱的功能"></a>利用spring框架 mail 和自己的邮箱实现注册邮箱的功能</h2><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>上面导入所需要的框架</p><pre><code>   @AutowiredMailSender mailSender;</code></pre><p>自动导入MailSender<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> datasource:</span><br><span class="line">   driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">   url: jdbc:mysql://localhost:3306/study-project?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">   username: root</span><br><span class="line">   password: 123456789</span><br><span class="line"> mail:</span><br><span class="line">   default-encoding: utf-8</span><br><span class="line">   host: smtp.139.com</span><br><span class="line">   username: 邮箱地址</span><br><span class="line">   password: 0b63a830468ccd 授权码</span><br><span class="line">   protocol: smtp</span><br><span class="line">   port: 465</span><br><span class="line">   properties:</span><br><span class="line">         from: 邮箱地址</span><br><span class="line">         mail:</span><br><span class="line">           smtp:</span><br><span class="line">             auth: true</span><br><span class="line">             starttls:</span><br><span class="line">               enable: true</span><br><span class="line">             ssl:</span><br><span class="line">               enable: true</span><br></pre></td></tr></table></figure><br>上面把相应的配置配一下，记住ssl，和非ssl， port端口不一样，记得改一下，现在开启了 ssl，不开启端口改为25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendVaildateEmail(String email)&#123;</span><br><span class="line">            int a= (int) (Math.random()*900000)+100000;</span><br><span class="line">        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();</span><br><span class="line">        simpleMailMessage.setFrom(b);</span><br><span class="line">        simpleMailMessage.setTo(email);</span><br><span class="line">        simpleMailMessage.setSubject(&quot;Spring实战2验证邮件&quot;);</span><br><span class="line">        simpleMailMessage.setText(&quot;验证码是：&quot;+a);</span><br><span class="line">        try&#123;</span><br><span class="line">            mailSender.send(simpleMailMessage);</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;catch (MailException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意setfrom是发件的是谁<br>setto是发给了谁<br>setsubject,是发件的主题是啥<br>settext,是发件的内容是啥。</p><p>上面首先创建SimpleMailMessage实例，将相应的内容填进去 ，然后mailSender.send(simpleMailMessage)直接发送</p><h2 id="登录权限验证"><a href="#登录权限验证" class="headerlink" title="登录权限验证"></a>登录权限验证</h2><p>Spring Context 本身并不直接存储登录信息，但它可以管理和配置与登录相关的组件。例如，Spring Security 是一个用于保护 Spring 应用程序的框架，它可以与 Spring Context 集成来处理身份验证和授权。</p><p>在这种情况下，Spring Context 会管理与登录相关的 Bean，例如用户详情服务（UserDetailsService）、身份验证管理器（AuthenticationManager）等。这些组件会处理用户登录信息的验证和存储，但实际的登录信息（如用户名和密码）通常存储在数据库或其他持久化存储中。</p><h1 id="Spring-Security-1"><a href="#Spring-Security-1" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>Spring Security 默认会拦截未登录的用户</p><h2 id="Spring-Security-使用过滤器链来处理所有进入的-HTTP-请求，"><a href="#Spring-Security-使用过滤器链来处理所有进入的-HTTP-请求，" class="headerlink" title="Spring Security 使用过滤器链来处理所有进入的 HTTP 请求，"></a>Spring Security 使用过滤器链来处理所有进入的 HTTP 请求，</h2><p>下面是某网站系统的Security,我将详细给你分析讲一下，各个究竟是干啥的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line"> public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">     return http</span><br><span class="line">             .authorizeHttpRequests()</span><br><span class="line">             .requestMatchers(&quot;/api/auth/**&quot;)</span><br><span class="line">             .permitAll()</span><br><span class="line">             .anyRequest()</span><br><span class="line">             .authenticated()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .formLogin()</span><br><span class="line">             .loginProcessingUrl(&quot;/api/auth/login&quot;)</span><br><span class="line">             .successHandler(this::onAuthenticationSuccess</span><br><span class="line"></span><br><span class="line">             )</span><br><span class="line">             .failureHandler(this::onAuthenticationFailure</span><br><span class="line"></span><br><span class="line">             )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .logout()</span><br><span class="line">             .logoutUrl(&quot;/api/auth/logout&quot;)</span><br><span class="line">             .logoutSuccessHandler(this::onAuthenticationSuccess)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .rememberMe()</span><br><span class="line">             .rememberMeParameter(&quot;remember&quot;)</span><br><span class="line">             .tokenRepository(this.tokenRepository())</span><br><span class="line">             .tokenValiditySeconds(3600*24)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .csrf()</span><br><span class="line">             .disable()</span><br><span class="line">             .cors()</span><br><span class="line">             .configurationSource(this.corsConfigurationSource())</span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .exceptionHandling()</span><br><span class="line">             .authenticationEntryPoint(this::onAuthenticationFailure)</span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    return http</span><br><span class="line">        .authorizeHttpRequests()</span><br><span class="line">        .requestMatchers(&quot;/api/auth/**&quot;)</span><br><span class="line">        .permitAll()</span><br><span class="line">        .anyRequest()</span><br><span class="line">        .authenticated()</span><br></pre></td></tr></table></figure><p>上面的authorizeHttpRequests() 开始配置请求授权</p><p>requestMatchers(“&#x2F;api&#x2F;auth&#x2F;“).permitAll()<strong>：允许 &#x2F;api&#x2F;auth&#x2F;</strong> 路径下的所有请求匿名访问，不需要认证</p><p>.anyRequest()<br>.authenticated()  其他所有请求都需要认证。</p><pre><code>   .and()    .formLogin()    .loginProcessingUrl(&quot;/api/auth/login&quot;)    .successHandler(this::onAuthenticationSuccess)    .failureHandler(this::onAuthenticationFailure)</code></pre><p>formLogin()：启用表单登录。</p><p>loginProcessingUrl(“&#x2F;api&#x2F;auth&#x2F;login”)：指定处理登录请求的 URL。</p><p>successHandler(this::onAuthenticationSuccess)：登录成功后的处理逻辑。</p><p>failureHandler(this::onAuthenticationFailure)：登录失败后的处理逻辑。</p><pre><code>    .and()    .logout()    .logoutUrl(&quot;/api/auth/logout&quot;)    .logoutSuccessHandler(this::onAuthenticationSuccess)</code></pre><p>logout()：启用注销功能</p><p>logoutUrl(“&#x2F;api&#x2F;auth&#x2F;logout”)：指定处理注销请求的 URL。</p><pre><code>    .and()    .rememberMe()    .rememberMeParameter(&quot;remember&quot;)    .tokenRepository(this.tokenRepository())    .tokenValiditySeconds(3600 * 24)</code></pre><p>rememberMe()：启用“记住我”功能。</p><p>rememberMeParameter(“remember”)：指定“记住我”参数的名称。</p><p>tokenRepository(this.tokenRepository())：指定用于存储“记住我”令牌的存储库。</p><p>tokenValiditySeconds(3600 * 24)：设置“记住我”令牌的有效期（秒）。</p><pre><code>    .and()    .csrf().disable()    .cors().configurationSource(this.corsConfigurationSource())</code></pre><p>csrf().disable()：禁用 CSRF 保护。</p><p>cors().configurationSource(this.corsConfigurationSource())：启用 CORS，并指定 CORS 配置源。</p><pre><code>    .and()    .exceptionHandling()    .authenticationEntryPoint(this::onAuthenticationFailure)</code></pre><p>exceptionHandling()：配置异常处理。</p><p>authenticationEntryPoint(this::onAuthenticationFailure)：指定未认证用户访问受保护资源时的处理逻辑。</p><pre><code>    .and()    .build();</code></pre><p>}</p><p>build()：构建并返回 SecurityFilterChain 对象。</p><h3 id="跨域资源CORS"><a href="#跨域资源CORS" class="headerlink" title="跨域资源CORS"></a>跨域资源CORS</h3><p>上方指定cors配置源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private CorsConfigurationSource corsConfigurationSource() &#123;</span><br><span class="line">    CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">    corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);</span><br><span class="line">    corsConfiguration.setAllowCredentials(true);</span><br><span class="line">    corsConfiguration.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">    corsConfiguration.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">    corsConfiguration.addExposedHeader(&quot;*&quot;);</span><br><span class="line">    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">    source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>CORS 配置：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CorsConfiguration corsConfiguration = new CorsConfiguration();：创建一个新的 CorsConfiguration 对象，用于存储 CORS 配置。</span><br><span class="line">允许所有来源：</span><br><span class="line">corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);：允许所有来源的请求。* 表示任何来源都可以访问。</span><br><span class="line">允许携带凭证：</span><br><span class="line">corsConfiguration.setAllowCredentials(true);：允许请求携带凭证（如 cookies）。</span><br><span class="line">允许所有请求头：</span><br><span class="line">corsConfiguration.addAllowedHeader(&quot;*&quot;);：允许所有请求头。</span><br><span class="line">允许所有 HTTP 方法：</span><br><span class="line">corsConfiguration.addAllowedMethod(&quot;*&quot;);：允许所有 HTTP 方法（如 GET、POST、PUT、DELETE 等）。</span><br><span class="line">暴露所有响应头：</span><br><span class="line">corsConfiguration.addExposedHeader(&quot;*&quot;);：允许客户端访问所有响应头。</span><br><span class="line">注册 CORS 配置：</span><br><span class="line">UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();：创建一个 UrlBasedCorsConfigurationSource 对象，用于注册 CORS 配置。</span><br><span class="line">source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);：将 CORS 配置应用于所有路径（/**）。</span><br><span class="line">返回 CORS 配置源：</span><br><span class="line">return source;：返回配置好的 CorsConfigurationSource 对象。</span><br></pre></td></tr></table></figure><h3 id="究竟谁开启的跨域的请求"><a href="#究竟谁开启的跨域的请求" class="headerlink" title="究竟谁开启的跨域的请求"></a>究竟谁开启的跨域的请求</h3><p>答案，他们共同作用导致不用在Controller加上@CrossOrigin这个注解了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.setAllowCredentials(true);</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>他们真是让我醉了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);：允许所有来源的请求。</span><br><span class="line">corsConfiguration.setAllowCredentials(true);：允许发送凭证（如 cookies）。</span><br><span class="line">corsConfiguration.addAllowedHeader(&quot;*&quot;);：允许所有请求头。</span><br><span class="line">corsConfiguration.addAllowedMethod(&quot;*&quot;);：允许所有 HTTP 方法（如 GET、POST、PUT、DELETE 等）。</span><br><span class="line">corsConfiguration.addExposedHeader(&quot;*&quot;);：允许客户端访问所有响应头</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使得跨域请求在全局范围内被允许，而不需要在每个 Controller 上单独配置 @CrossOrigin</p><h3 id="在拦截器中返回用户信息"><a href="#在拦截器中返回用户信息" class="headerlink" title="在拦截器中返回用户信息"></a>在拦截器中返回用户信息</h3><p>在mvcConfiguration里,配置拦截器，拦截所有，并放开，注册页面请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> @Resource</span><br><span class="line">    AuthorizeInterceptor authorizeInterceptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(authorizeInterceptor)</span><br><span class="line">                .addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/api/auth/**&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将请求后的个人信息数据,存到Session里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AuthorizeInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        SecurityContext context= SecurityContextHolder.getContext();</span><br><span class="line">        Authentication authentication=context.getAuthentication();</span><br><span class="line">         User user = (User) authentication.getPrincipal();</span><br><span class="line">        String username = user.getUsername();</span><br><span class="line">        Account account = userMapper.finduser(username);</span><br><span class="line">        request.getSession().setAttribute(&quot;account&quot;,account);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在这讲一讲,注册拦截问题</strong></p><p>拦截器的 preHandle 方法会尝试从当前的安全上下文中获取用户信息，并将用户的账户信息存储到会话中。然而，在用户登录请求时，用户还没有经过身份验证，<br>所以安全上下文中没有用户信息。这会导致 preHandle 方法无法正确处理登录请求，可能会抛出异常或导致其他问题。</p><p>通过排除 &#x2F;api&#x2F;auth&#x2F;** 路径，你可以确保登录请求不会经过拦截器的处理逻辑，从而避免这些问题。登录请求可以正常进行，用户身份验证成功后，其他请求才会经过拦截器进行预处理。</p><h2 id="Spring-Security-登录思路"><a href="#Spring-Security-登录思路" class="headerlink" title="Spring Security 登录思路"></a>Spring Security 登录思路</h2><p>注意它不走Controller层，在拦截器层，直接拦下，在拦截器那一层，首先会在拦截器这一层会有实现UserDetailsService的Service层的注入,<br>调用Service层的里面的UserDetail方法，在这一层将用usermapper层，进行用户名查找，所有数据  注意只有一个参数，SpringSecurity会自动识别用户名<br>，用用户名查找所有数据，之后在Configuration进行第二步，整合BCcript到AuthenticationManager authenticationManager这一方法<br>自动将密码和数据库查到的想对比，成功调用.successHandler （this::onAuthenticationSuccess），失败调用.failureHandler(this::onAuthenticationFailure）</p><pre><code>       、</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Connfiguration</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(&quot;/api/auth/login&quot;)</span><br><span class="line">                .successHandler(this::onAuthenticationSuccess</span><br><span class="line"></span><br><span class="line">                )</span><br><span class="line">                .failureHandler(this::onAuthenticationFailure</span><br><span class="line"></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl(&quot;/api/auth/logout&quot;)</span><br><span class="line">                .logoutSuccessHandler(this::onAuthenticationSuccess)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationManager authenticationManager(HttpSecurity httpSecurity)throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        return httpSecurity</span><br><span class="line">                .getSharedObject(AuthenticationManagerBuilder.class)</span><br><span class="line">                .userDetailsService(a)</span><br><span class="line">                .passwordEncoder(passwordEncoder())</span><br><span class="line">                .and()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       @Bean</span><br><span class="line">    public BCryptPasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UserService</span><br><span class="line">                        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">                            if (username==null)</span><br><span class="line">                                throw new UsernameNotFoundException(&quot;用户名为空&quot;);</span><br><span class="line">                            User user = userMapper.FindAllByUsernameOrEmail(username);</span><br><span class="line">                            if(user==null)</span><br><span class="line">                                throw new UsernameNotFoundException(&quot;用户名不存在&quot;);</span><br><span class="line"></span><br><span class="line">                            return org.springframework.security.core.userdetails.User</span><br><span class="line">                                    .withUsername(user.getUsername())</span><br><span class="line">                                    .password(user.getPassword())</span><br><span class="line">                                    .roles(&quot;user&quot;)</span><br><span class="line">                                    .build();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="redis进行验证码校验"><a href="#redis进行验证码校验" class="headerlink" title="redis进行验证码校验"></a>redis进行验证码校验</h2><p>pom 导入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在UserService注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">StringRedisTemplate template;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**注意主要业务逻辑处理都在Service层，Controller，只要结果，它根据结果进行返回操作，所以在这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public String sendVaildateEmail(String email, String Sessionid,boolean hashAccound)&#123;</span><br><span class="line">                           int a= (int) (Math.random()*900000)+100000;</span><br><span class="line">                       String key=&quot;email:&quot;+email+&quot;sessionid:&quot;+Sessionid+hashAccound;</span><br><span class="line">                       if(Boolean.TRUE.equals(template.hasKey(key)))&#123;</span><br><span class="line">                           Long aLong = Optional.ofNullable(template.getExpire(key, TimeUnit.SECONDS)).orElse(0l);</span><br><span class="line">                           if(aLong&gt;120) return &quot;请求频繁，稍后再试&quot;;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (hashAccound&amp;&amp;userMapper.FindAllByUsernameOrEmail(email)==null)&#123;</span><br><span class="line">                           return &quot;没有此邮件地址的账户&quot;;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                       if(!hashAccound&amp;&amp;userMapper.FindAllByUsernameOrEmail(email)!=null)&#123;</span><br><span class="line"></span><br><span class="line">                           return &quot;邮箱已被其他用户注册&quot;;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       SimpleMailMessage simpleMailMessage = new SimpleMailMessage();</span><br><span class="line">                       simpleMailMessage.setFrom(b);</span><br><span class="line">                       simpleMailMessage.setTo(email);</span><br><span class="line">                       simpleMailMessage.setSubject(&quot;Spring实战2验证邮件&quot;);</span><br><span class="line">                       simpleMailMessage.setText(&quot;验证码是：&quot;+a);</span><br><span class="line">                       try&#123;</span><br><span class="line">                           mailSender.send(simpleMailMessage);</span><br><span class="line"></span><br><span class="line">                           template.opsForValue().set(key,String.valueOf(a),3, TimeUnit.MINUTES);</span><br><span class="line">                           return null;</span><br><span class="line"></span><br><span class="line">                       &#125;catch (MailException e)&#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           return &quot;请联系管理员，检查邮箱&quot;;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>从上面里面抽出redis的用法为</p><p>template.opsForValue().set(key,String.valueOf(a),3, TimeUnit.MINUTES);<br>设置key，和有效期，<br><code>template.getExpire(key, TimeUnit.SECONDS)</code>从里面得到验证码，的时间</p><p>template.hasKey(key))是否相等。<br>上面的邮箱发送请看上面的章节，这里不在讲。</p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习SpringBoot3+ssm+spring6三月后疑难点总结</title>
      <link href="/2024/07/04/SpringBoot3+ssm+spring6/"/>
      <url>/2024/07/04/SpringBoot3+ssm+spring6/</url>
      
        <content type="html"><![CDATA[<h1 id="拖延太拖延了"><a href="#拖延太拖延了" class="headerlink" title="拖延太拖延了"></a>拖延太拖延了</h1><p>本来就没有多少时间还拖沓，也是很服自己的</p><h1 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h1><h2 id="Autowored和Resource"><a href="#Autowored和Resource" class="headerlink" title="Autowored和Resource"></a>Autowored和Resource</h2><p>Autowored</p><p>是由Spring提供的一个注解，用于自动装配，注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。<br>Qualifier<br>bean定义或者AOP切面的引用。这个注解用于指定在依赖注入时，应该使用哪个特定的bean实例，即使它们具有相同的类型。当你有多个同类型的bean存在，并且希望明确指定其中一个时，可以使用<code>@Qualifier</code>来区分</p><p>Resource</p><p>注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在@Bean标识之后，加上@Scope可以实现单例和多例模式，<br>@Scope(“prototype”)&#96; 是Spring框架中的一个作用域注解，它用于定义Spring管理的bean的生命周期。在Spring中，bean可以分为几种不同的作用域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Singleton (默认): 单例模式，意味着在整个应用上下文中只有一个实例。这是最常见的作用域，适用于那些不需要修改状态或者需要共享数据的bean。</span><br><span class="line"></span><br><span class="line">2. Prototype: 原型模式，每个请求都会创建一个新的bean实例。这意味着每次通过@Autowired注入到需要这个bean的地方，都会得到一个新的对象，适合用于创建临时的对象或者不可变的对象。</span><br><span class="line"></span><br><span class="line">当你在bean上使用`@Scope(&quot;prototype&quot;)`时，Spring会在每次bean被请求时都创建一个新的实例，而不是在整个应用程序运行期间只创建一次。这对于那些需要根据请求或用户行为动态创建对象的场景非常有用，比如缓存策略或者生成报告时。</span><br></pre></td></tr></table></figure><h2 id="多个配置类-Import导入"><a href="#多个配置类-Import导入" class="headerlink" title="多个配置类@Import导入"></a>多个配置类@Import导入</h2><p>@Import 注释允许从另一个配置类加载 @Bean 定义，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public A a() &#123;</span><br><span class="line">    return new A();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public B b() &#123;</span><br><span class="line">    return new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的操作A导入B配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line"></span><br><span class="line">    // now both beans A and B will be available...</span><br><span class="line">    A a = ctx.getBean(A.class);</span><br><span class="line">    B b = ctx.getBean(B.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面实例化B但是用了A的里面的Bean，就是这个意思</p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用idea写前端vue spring实战2</title>
      <link href="/2024/07/04/%E7%94%A8idea%E5%86%99%E5%89%8D%E7%AB%AFvue/"/>
      <url>/2024/07/04/%E7%94%A8idea%E5%86%99%E5%89%8D%E7%AB%AFvue/</url>
      
        <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>首先必须安装node.js，这个之前已经安装过了，之后用了spring的生成器，用来快速构建spring，<br>之后在控制端用了npm install -g create-vue这个是成功了但是用create-vue的时候失败了<br>之后用npm init vue@latest成功，就是这个<br>最后在构建模块把前端的模块变成和后端一样。</p><h3 id="两个构建方式有什么不同"><a href="#两个构建方式有什么不同" class="headerlink" title="两个构建方式有什么不同"></a>两个构建方式有什么不同</h3><p>create-vue</p><p>全局安装：需要先通过 npm install -g create-vue 全局安装。<br>命令简洁：安装后可以直接使用 create-vue 命令创建项目。<br>基于 Vite：创建的项目默认使用 Vite 作为构建工具。</p><p>npm init vue@latest</p><p>无需全局安装：直接使用 npm init vue@latest 命令，无需预先安装其他工具。<br>交互式配置：命令执行后，会进入一个交互式的配置界面，允许你选择项目的各种配置选项2。<br>基于 Vite：同样使用 Vite 作为构建工具。</p><h3 id="什么是vite"><a href="#什么是vite" class="headerlink" title="什么是vite"></a>什么是vite</h3><p>Vite（法语意为 “快速的”，发音 &#x2F;vit&#x2F;，发音同 “veet”）是一种新型前端构建工具，旨在显著提升前端开发体验12。</p><figure class="highlight plaintext"><figcaption><span>“快速的”，发音</span><a href="/vit/，发音同">“veet”）是一种新型前端构建工具，旨在显著提升前端开发体验12。</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">主要特点</span><br><span class="line">极速的服务启动：使用原生 ES 模块文件，无需打包，启动速度极快2。</span><br><span class="line">模块热更新（HMR）：提供快速的模块热替换，无论应用程序大小如何，都能保持极快的热重载2。</span><br><span class="line">丰富的功能：对 TypeScript、JSX、CSS 等支持开箱即用2。</span><br><span class="line">优化的构建：使用 Rollup 打包代码，输出高度优化的静态资源1。</span><br><span class="line">插件 API：提供灵活的插件 API 和 JavaScript API，带来高度的可扩展性1。</span><br></pre></td></tr></table></figure><h2 id="vue3前置工作"><a href="#vue3前置工作" class="headerlink" title="vue3前置工作"></a>vue3前置工作</h2><p>安装完之后用已经得到了基本的vue3基本框架，接下来把它的初始页面删了，留下空白面板，接下来用到vue3的框架<code>element-plus</code>框架快速构建vue3<br>然后再安装vue-axios两者的具体命令为 <code>npm install element-plus --save</code>和<code>npm install vue-axios --save</code></p><p>下面是两者的具体介绍</p><p>Element Plus：<br>Element Plus 是一个基于 Vue 3 的高质量 UI 组件库12。它提供了丰富的组件，如表格、表单、按钮、导航、通知等，帮助开发者快速构建高质量的 Web 应用3。</p><p>vue-axios：<br>vue-axios 是一个将 axios 集成到 Vue.js 中的小型封装库。axios 是一个基于 promise 的 HTTP 客户端，用于向 API 发送请求并处理响应数据6。</p><h3 id="ElementPlusResolver按需自动导入配置插件"><a href="#ElementPlusResolver按需自动导入配置插件" class="headerlink" title="ElementPlusResolver按需自动导入配置插件"></a>ElementPlusResolver按需自动导入配置插件</h3><p>首先全局安装了插件<code>npm install -D unplugin-vue-components unplugin-auto-import</code>之两个插件详情在<code>https://element-plus.org/zh-CN/guide/quickstart.html</code><br>我这里出现错误记得把前面的导入也导一下,</p><h2 id="jsp与vue3的区别"><a href="#jsp与vue3的区别" class="headerlink" title="jsp与vue3的区别"></a>jsp与vue3的区别</h2><p>我写页面用jsp习惯了，但是好像jsp页面被淘汰了，现在vue页面已经是主流了<br>下面是两者的详细解释</p><p>目前，Vue 在前端开发中比 JSP 更受欢迎，尤其是在构建现代化的单页面应用（SPA）时¹²。Vue 提供了更好的用户体验和开发效率，支持组件化开发和前后端分离，这使得它在前端开发者中广受欢迎¹²。</p><p>JSP 主要用于传统的 Java Web 开发，虽然在一些老旧项目中仍然使用，但新项目中使用 JSP 的情况已经大大减少¹²。</p><p>原来我已经落伍了，</p><h2 id="如上文所说我又安装-axios"><a href="#如上文所说我又安装-axios" class="headerlink" title="如上文所说我又安装 axios"></a>如上文所说我又安装 axios</h2><p><code>npm install axios</code></p><p>这个插件主要是为了，浏览器无缝链接后端，处理http请求，无缝链接的框架又，vue，rest等，具体介绍，所示</p><ul><li>Axios 是一个基于 Promise 的 JavaScript HTTP 库，主要用于浏览器和 Node.js 环境中的客户端应用。它的主要作用是提供一个简单、统一的方式来发送 HTTP 请求，并处理响应。Axios 支持浏览器和 Node.js 中的同步和异步请求，可以与各种现有的框架（如 Vue.js、React、Angular 等）无缝集成。</li></ul><blockquote><p>以下是 Axios 的一些关键特性：</p><ol><li><p><strong>Promise-based</strong>: Axios 返回的是一个 Promise 对象，可以使用 <code>.then()</code> 和 <code>.catch()</code> 来处理成功和错误响应。</p></li><li><p><strong>跨域支持</strong>: 它内置了对 CORS（跨源资源共享）的支持，可以在发送请求时自动添加必要的头信息。</p></li><li><p><strong>转换请求和响应数据</strong>: Axios 可以自动转换 JSON 数据，支持配置请求和响应的数据格式（如 JSON、XML、Form Data 等）。</p></li><li><p><strong>拦截器</strong>: Axios 提供了全局请求和响应拦截器，允许你在发送请求前或响应返回后执行自定义逻辑。</p></li><li><p><strong>取消请求</strong>: 可以通过 <code>cancel</code> 方法取消正在执行的请求。</p></li><li><p><strong>并发请求管理</strong>: 支持批量请求和取消批量请求，可以控制并发请求的数量。</p></li></ol></blockquote><p><strong>Axios</strong> 是一个基于 Promise 的 HTTP 客户端库，可以在浏览器和 Node.js 中使用。它独立于任何框架，可以在各种前端项目中使用¹²。</p><p><strong>vue-axios</strong> 是一个将 Axios 集成到 Vue.js 的包装器。它允许你像插件一样安装和使用 Axios，从而简化了在 Vue 组件中使用 Axios 的过程³⁴。具体来说，vue-axios 使得你不需要在每个组件中单独导入 Axios，而是可以通过 <code>this.$http</code> 或 <code>this.axios</code> 直接访问³。</p><p>总结一下：</p><ul><li><strong>Axios</strong>：独立库，适用于各种前端项目。</li><li><strong>vue-axios</strong>：Vue.js 插件，简化了在 Vue 项目中使用 Axios 的过程。</li></ul><h2 id="Element-Plus框架自带表单检验功能"><a href="#Element-Plus框架自带表单检验功能" class="headerlink" title="Element Plus框架自带表单检验功能"></a>Element Plus框架自带表单检验功能</h2><p>把表单里的内容框放在&lt;el -from&gt;表单里，<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">         &lt;el-form-item prop=&quot;username&quot;&gt;</span><br><span class="line">             &lt;el-input v-model=&quot;form.username&quot; style=&quot;width: 400px;margin-left: 45px ;margin-top: 15px&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;  &gt;</span><br><span class="line">             &lt;template #prefix&gt;</span><br><span class="line">         &lt;el-icon&gt;&lt;User/&gt;&lt;/el-icon&gt;</span><br><span class="line">           &lt;/template&gt;</span><br><span class="line">           &lt;/el-input&gt;</span><br><span class="line">     &lt;/el-form-item&gt;&#125;  </span><br></pre></td></tr></table></figure><br>下面是具体的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const validateUsername= (rule, value, callback) =&gt; &#123;</span><br><span class="line">  if (value === &#x27;&#x27;) &#123;</span><br><span class="line">    callback(new Error(&#x27;请输入用户名&#x27;))</span><br><span class="line">  &#125; else if(!/^(?:(?=[\u4e00-\u9fa5])[\u4e00-\u9fa5]*|(?=[a-zA-Z])[a-zA-Z]*)$/.test(value))&#123;</span><br><span class="line">    callback(new Error(&quot;用户名只能为中文或者英文&quot;))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码定义了validateUsername的函数创建判断规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const rules=</span><br><span class="line">      &#123;</span><br><span class="line">        username: [</span><br><span class="line">          &#123; validator:validateUsername, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125;,</span><br><span class="line">          &#123; min: 3, max: 15, message: &#x27;长度为3-15&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面的代码引用了username就是<strong>prop</strong>，另外还有rules规则。<br>注意其中的validator指定了一个函数这个函数会在特定的事件（如输入框失去焦点或内容改变）触发时执行，</p><h2 id="验证邮箱是否合法-是否展示获取验证码按钮出现"><a href="#验证邮箱是否合法-是否展示获取验证码按钮出现" class="headerlink" title="验证邮箱是否合法-是否展示获取验证码按钮出现"></a>验证邮箱是否合法-是否展示获取验证码按钮出现</h2><p><code> &lt;el-button type=&quot;primary&quot; style=&quot; margin-top: 10px&quot; :disabled=&quot;!isEmailValid&quot;&gt;获取验证码&lt;/el-button&gt;</code><br>上面的 :disabled</p><p>用于控制元素的禁用状态。它的值是一个布尔表达式，当表达式的值为 true 时，元素会被禁用；当值为 false 时，元素会被启用<br><code>&lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; @validate=&quot;onValidate&quot;&gt;</code><br>上面的@validate动态绑定了<strong>表单</strong>里面的所有的prop都要验证<br>并且声明了<code>const isEmailValid= ref (false)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const onValidate =(prop,isValid)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (prop===&#x27;email&#x27;)</span><br><span class="line">    isEmailValid.value=isValid</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说@validate&#x3D;”onValidate”每次验证都会调用一次，假设验证的是email，注意看如果email验证通过，那么isVaild为true<br>那么prop email,isVaild true,被带入，if语句会成功，isEmailValid会被设置为true。那么:disabled&#x3D;的语句是真就禁用，又加上 ！isEmailValid会被设置为false，为假。不禁用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    type: &#x27;email&#x27;,</span><br><span class="line">    message: &#x27;请输入合法的邮箱地址&#x27;,</span><br><span class="line">    trigger: [&#x27;blur&#x27;, &#x27;change&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123; required: true, message: &#x27;请输入邮箱地址&#x27;, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>规则里面的是blur，和changge。意思是他聚焦和改变了，就验证，required是否必须验证</p><h3 id="验证表单所有框全部正确，Element-Plus，表单提供了一个validate"><a href="#验证表单所有框全部正确，Element-Plus，表单提供了一个validate" class="headerlink" title="验证表单所有框全部正确，Element Plus，表单提供了一个validate"></a>验证表单所有框全部正确，Element Plus，表单提供了一个validate</h3><p>在表单上加上引用组件 <code>&lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; @validate=&quot;onValidate&quot; ref=&quot;formRef&quot;&gt;</code><br>ref&#x3D;   自定义<br>它的目的是访问和操作表单组件实例，进行验证<br>在script里面加上<br><code> const formRef=ref()</code></p><p>在立即注册的按钮上加上<code>&lt;el-button style=&quot;width: 270px ;margin-left: 80px&quot; type=&quot;warning&quot; @click=&quot;register()&quot;&gt;立即注册&lt;/el-button&gt;</code><br>click函数<br>注册调用 formRef.value.validate操作表单进行验证isValid是否为真</p><figure class="highlight plaintext"><figcaption><span>register </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    formRef.value.validate((isValid)=&gt;&#123;</span><br><span class="line">      if (isValid)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        ElMessage.warning(&quot;请填写完整表单&quot;)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    const validatePassword_repeat = (rule, value, callback) =&gt; &#123;</span><br><span class="line">      if (value === &#x27;&#x27;) &#123;</span><br><span class="line">        callback(new Error(&#x27;请再次确认密码&#x27;))</span><br><span class="line">      &#125; else if (value !== form.password) &#123;</span><br><span class="line">        callback(new Error(&quot;两次密码不同&quot;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const rules=&#123;</span><br><span class="line">        password_repeat:[</span><br><span class="line">        </span><br><span class="line">            &#123; validator:validatePassword_repeat, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125;,</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">          ],</span><br><span class="line">          &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面自定义自定义的验证函数，用于验证两次输入的密码是否一致。<br>上面的3个参数为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rule：验证规则对象，通常包含验证的相关信息。</span><br><span class="line">value：当前输入框的值，即用户输入的内容。</span><br><span class="line">callback：回调函数，用于返回验证结果。</span><br></pre></td></tr></table></figure><p>callback()</p><p>函数用于返回验证结果。它接受一个参数，如果传递的是 Error 对象，则表示验证失败；如果不传递参数或传递 null，则表示验证通过。</p><p>trigger 指定了验证触发的时机，这里是 blur（失去焦点）和 change（值改变）时触发验证。</p><h2 id="Element-UI-组件"><a href="#Element-UI-组件" class="headerlink" title="Element UI 组件"></a>Element UI 组件</h2><h3 id="步骤条"><a href="#步骤条" class="headerlink" title="步骤条"></a>步骤条</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-steps style=&quot;max-width: 600px&quot; :active=&quot;active&quot; finish-status=&quot;success&quot;&gt;</span><br><span class="line">    &lt;el-step title=&quot;Step 1&quot; /&gt;</span><br><span class="line">    &lt;el-step title=&quot;Step 2&quot; /&gt;</span><br><span class="line">    &lt;el-step title=&quot;Step 3&quot; /&gt;</span><br><span class="line">  &lt;/el-steps&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>加在<template> 里面 </template><br>最少的步骤条为2，也就是从0,1开始,需要定宽的步骤条时，设置 space 属性即可,里面有好多用法，具体你可以看Element的官网。<br>这里只讲，本实战用到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-steps style=&quot;max-width: 600px&quot; :active=&quot;active&quot; finish-status=&quot;success&quot;&gt;</span><br><span class="line">          &lt;el-step title=&quot;验证电子邮件&quot; /&gt;</span><br><span class="line">          &lt;el-step title=&quot;修改密码&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/el-steps&gt;</span><br></pre></td></tr></table></figure><p>可以在里面设置中文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;active===0&quot;&gt;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>通过 v-if可以展示或则隐藏，v-if指令可以用于隐藏元素。当active变量的值不等于0时，这个<div>元素及其内容将不会被渲染到页面上，相当于被隐藏了</p><pre><code>            // 开始或重置表单验证和提交过程的函数const startreset = () =&gt; &#123;            // 验证表单字段formRef.value.validate((isValid) =&gt; &#123;            // 如果表单有效if (isValid) &#123;           // 发送POST请求到指定的API端点，附带表单数据post(&quot;api/auth/start-refister&quot;, &#123;email: form.email, // 用户的邮箱code: form.code   // 验证码&#125;, () =&gt; &#123;          // 请求成功后增加active值active.value++;&#125;);&#125; else &#123;          // 如果表单无效，显示警告信息ElMessage.warning(&quot;请填写邮箱和表单&quot;);&#125;&#125;);&#125;</code></pre><p>注意validate是ELement提供的回调函数，isvailid是他提供的他只真或者假的，在这里注意看它的  active.value++;</p><h2 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">import &#123;ElMessage&#125; from &quot;element-plus&quot;;</span><br><span class="line"></span><br><span class="line">const defaultError=()=&gt;ElMessage.error(&quot;发生了一些错误，请联系管理员&quot;)</span><br><span class="line"></span><br><span class="line">const defaultFailure=(message)=&gt;ElMessage.warning(message)</span><br><span class="line"></span><br><span class="line">function post(url,data,success,failure=defaultFailure,error=defaultError)&#123;</span><br><span class="line">        axios.post(url,data,&#123;</span><br><span class="line">            headers:&#123;</span><br><span class="line">                &#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            withCredentials:true</span><br><span class="line">        &#125;).then((&#123;data&#125;)=&gt;&#123;</span><br><span class="line">            if(data.success)</span><br><span class="line">                success(data.message,data.status)</span><br><span class="line">            else</span><br><span class="line">                failure(data.message,data.status)</span><br><span class="line"></span><br><span class="line">        &#125;).catch(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我来讲一讲</p><p>headers: { ‘Content-Type’: ‘application&#x2F;x-www-form-urlencoded’ }</p><p>这行代码设置了 HTTP 请求的头部信息，具体来说是 Content-Type 头部。</p><p>Content-Type: 这个头部告诉服务器请求中的数据是什么类型。在这里，application&#x2F;x-www-form-urlencoded 表示数据将以键值对的形式编码，类似于 URL 参数。这种编码方式常用于表单提交。<br>作用: 服务器根据 Content-Type 头部来解析请求体中的数据。如果不设置这个头部，服务器可能无法正确解析数据，导致请求失败。</p><p><strong>当我们使用键值对向后端发数据的时候</strong></p><pre><code>假设你有以下数据需要发送：JSON&#123;&quot;name&quot;: &quot;John Doe&quot;,&quot;age&quot;: 30,&quot;city&quot;: &quot;New York&quot;&#125;AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.使用 application/x-www-form-urlencoded 编码后，这些数据会变成：name=John+Doe&amp;age=30&amp;city=New+York</code></pre><p><strong>如果想向后端发送json数据</strong></p><figure class="highlight plaintext"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Content-Type&#x27;: &#x27;application/json&#x27; // 设置请求头，指定内容类型为 application/json</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是模仿数据发送的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userData = &#123;</span><br><span class="line">    username: &quot;john_doe&quot;,</span><br><span class="line">    password: &quot;securepassword&quot;,</span><br><span class="line">    email: &quot;john@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器接受</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/register&quot;)</span><br><span class="line">    public ResponseEntity&lt;String&gt; registerUser(@RequestBody User user) &#123;</span><br><span class="line">        // 处理注册逻辑</span><br><span class="line">        return ResponseEntity.ok(&quot;User registered successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的作用<br><code>@RequestBody 注解用于将请求体中的 JSON 数据映射到 User 对象。</code></p><p>看到这个地方心里就啥就明白了吧！</p><p><strong>withCredentials: true</strong></p><p>   这行代码设置了跨域请求时是否携带凭证（如 cookies、HTTP 认证信息等）。</p><p>withCredentials: 这是一个布尔值选项，表示是否允许跨域请求携带凭证</p><p><strong>在继续看then</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.then((&#123;data&#125;)=&gt;&#123;</span><br><span class="line">            if(data.success)</span><br><span class="line">                success(data.message,data.status)</span><br><span class="line">            else</span><br><span class="line">                failure(data.message,data.status)</span><br><span class="line"></span><br><span class="line">        &#125;).catch(error)</span><br></pre></td></tr></table></figure><p>then,代表，请求成功之后的调用段代码 then(({ data }) &#x3D;&gt; { … }) 部分使用了解构赋值，将响应对象中的 data 属性提取出来，直接使用 data 变量，而不需要写成 response.data</p><p>双括号是then也需要个回调函数作为参数，而这个回调函数本身也需要调用。第一个括号是调用 then 方法，第二个括号是定义并调用回调函数</p><p><strong>catch</strong><br>catch 方法接收一个回调函数，该函数会在请求失败时执行。<br>回调函数的参数是错误对象 error。<br>在这里，catch 方法调用了 error 函数（即 defaultError），显示错误消息</p><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p>如同上一小节，这节将讲一讲跨域请求与<br><strong>withCredentials: true</strong></p><p>这行代码设置了跨域请求时是否携带凭证（如 cookies、HTTP 认证信息等）。</p><p>withCredentials: 这是一个布尔值选项，表示是否允许跨域请求携带凭证</p><p><code>withCredentials: true 和 corsConfiguration.setAllowCredentials(true)</code></p><p>前端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前端</span><br><span class="line">withCredentials: true: 这是在前端配置中使用的，告诉浏览器在跨域请求时携带凭证（如 cookies）。</span><br><span class="line">JavaScript</span><br><span class="line"></span><br><span class="line">axios.post(url, data, &#123;</span><br><span class="line">withCredentials: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corsConfiguration.setAllowCredentials(true): 这是在后端配置中使用的，告诉服务器允许跨域请求携带凭证。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这两者结合使用时，前端会发送凭证，后端会接受这些凭证，从而实现跨域请求时的身份验证。</strong></p><p> @CrossOrigin</p><p>@CrossOrigin: 这是一个注解，用于配置允许哪些域可以进行跨域请求。可以应用于控制器类或方法上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins = &quot;http://example.com&quot;)</span><br><span class="line">@GetMapping(&quot;/data&quot;)</span><br><span class="line">public ResponseEntity&lt;String&gt; getData() &#123;</span><br><span class="line">return ResponseEntity.ok(&quot;Some data&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用:</p><p>这个注解主要用于指定允许的跨域请求来源、方法等。它可以细粒度地控制哪些请求被允许跨域访问。</p><p>区别总结<br>配置范围:</p><figure class="highlight plaintext"><figcaption><span>和 setAllowCredentials 主要用于处理跨域请求时的凭证携带问题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin 用于配置允许的跨域请求来源、方法等，提供更全面的跨域控制。</span><br></pre></td></tr></table></figure><p>使用场景:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果你需要处理跨域请求时的身份验证问题，使用 withCredentials 和 setAllowCredentials。</span><br><span class="line">如果你需要配置哪些域可以进行跨域请求，使用 @CrossOrigin。</span><br></pre></td></tr></table></figure><p>灵活性:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin 可以在控制器或方法级别进行配置，灵活性更高。</span><br><span class="line">withCredentials 和 setAllowCredentials 主要用于全局配置跨域请求的凭证携带。</span><br></pre></td></tr></table></figure><h2 id="路由管理和全局守卫"><a href="#路由管理和全局守卫" class="headerlink" title="路由管理和全局守卫"></a>路由管理和全局守卫</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// 导入 Vue Router 所需的模块</span><br><span class="line">import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;</span><br><span class="line">// 从指定路径导入 store</span><br><span class="line">import &#123; useStore &#125; from &quot;@/stores/counter.js&quot;;</span><br><span class="line"></span><br><span class="line">// 创建一个新的路由实例</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  // 使用 HTML5 历史模式进行导航</span><br><span class="line">  history: createWebHistory(import.meta.env.BASE_URL),</span><br><span class="line">  // 定义应用的路由</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      // 欢迎视图的根路径</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      name: &#x27;welcome&#x27;,</span><br><span class="line">      // 懒加载欢迎视图组件</span><br><span class="line">      component: () =&gt; import(&#x27;@/views/weclcome.vue&#x27;),</span><br><span class="line">      // 定义欢迎视图的子路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          // 登录页面的默认子路由</span><br><span class="line">          path: &#x27;&#x27;,</span><br><span class="line">          name: &#x27;welcome-login&#x27;,</span><br><span class="line">          // 懒加载登录页面组件</span><br><span class="line">          component: () =&gt; import(&#x27;@/c*************.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // 注册页面的路由</span><br><span class="line">          path: &#x27;/re*****r&#x27;,</span><br><span class="line">          name: &#x27;welcome-RegisterPage&#x27;,</span><br><span class="line">          // 懒加载注册页面组件</span><br><span class="line">          component: () =&gt; import(&#x27;@/c***************e.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // 忘记密码页面的路由</span><br><span class="line">          path: &#x27;/fo***t&#x27;,</span><br><span class="line">          name: &#x27;welcome-forget&#x27;,</span><br><span class="line">          // 懒加载忘记密码页面组件</span><br><span class="line">          component: () =&gt; import(&#x27;@/*****************e.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      // 主索引视图的路由</span><br><span class="line">      path: &#x27;/i***x&#x27;,</span><br><span class="line">      name: &#x27;index&#x27;,</span><br><span class="line">      // 懒加载索引视图组件</span><br><span class="line">      component: () =&gt; import(&#x27;@/v*************vue&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 定义全局导航守卫</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // 获取 store 实例</span><br><span class="line">  const store = useStore()</span><br><span class="line">  // 如果用户已认证且尝试访问欢迎路由，则重定向到索引页面</span><br><span class="line">  if (store.auth.user != null &amp;&amp; to.name.startsWith(&#x27;welcome&#x27;)) &#123;</span><br><span class="line">    next(&#x27;/index&#x27;)</span><br><span class="line">  // 如果用户未认证且尝试访问索引路由，则重定向到欢迎页面</span><br><span class="line">  &#125; else if (store.auth.user == null &amp;&amp; to.fullPath.startsWith(&#x27;/index&#x27;)) &#123;</span><br><span class="line">    next(&#x27;/&#x27;)</span><br><span class="line">  // 如果路由不匹配任何定义的路由，则重定向到欢迎页面</span><br><span class="line">  &#125; else if (to.matched.length === 0) &#123;</span><br><span class="line">    next(&#x27;/&#x27;)</span><br><span class="line">  // 否则，继续导航到下一个路由</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 导出路由实例以供应用使用</span><br><span class="line">export default router</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>导入：导入 vue-router 中的必要模块和 @&#x2F;stores&#x2F;counter.js 中的 store。</p><p>创建路由：使用 createRouter 创建一个新的路由实例，使用 HTML5 历史模式和定义的路由。</p><p>定义路由：</p><p>根路径 (&#x2F;) 关联到 welcome 视图，该视图有子路由用于登录、注册和忘记密码页面。</p><p>&#x2F;index 路径关联到主 index 视图。</p><p>导航守卫：</p><p>在每次路由变化之前，beforeEach 守卫会检查用户的认证状态。</p><p>如果用户已认证且尝试访问欢迎路由，则重定向到索引页面。</p><p>如果用户未认证且尝试访问索引页面，则重定向到欢迎页面。</p><p>如果路由不匹配任何定义的路由，则重定向到欢迎页面。</p><p>否则，继续导航到下一个路由。</p><p>导出：导出路由实例以供应用使用。</p><h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">路由管理</span><br><span class="line">路由管理是指在单页应用（SPA）中，通过定义不同的路由来管理页面的导航。Vue Router 是 Vue.js 官方的路由管理器，它允许我们在 Vue 应用中轻松地定义和管理路由。</span><br><span class="line"></span><br><span class="line">基本概念</span><br><span class="line">路由：路由是 URL 与组件之间的映射关系。每个路由都包含一个路径和一个组件，当用户访问该路径时，Vue Router 会渲染对应的组件。</span><br><span class="line">路由表：路由表是一个数组，包含所有路由的定义。每个路由对象通常包含 path 和 component 属性。</span><br><span class="line">嵌套路由：嵌套路由允许我们在一个路由中定义子路由，从而实现多级导航结构。</span><br></pre></td></tr></table></figure><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全局守卫</span><br><span class="line">全局守卫是指在路由变化时执行的钩子函数。Vue Router 提供了三种全局守卫：</span><br><span class="line"></span><br><span class="line">beforeEach：在每次路由变化前执行。</span><br><span class="line">beforeResolve：在组件内守卫和异步路由组件被解析之后执行。</span><br><span class="line">afterEach：在每次路由变化后执行。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeEach：</span><br><span class="line">    to：即将进入的路由对象。</span><br><span class="line">    from：当前导航正要离开的路由对象。</span><br><span class="line">    next：必须调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</span><br><span class="line">    在 beforeEach 守卫中，我们可以添加逻辑来检查用户的权限或状态。例如，检查用户是否已登录，如果未登录则重定向到登录页面。</span><br><span class="line">afterEach：</span><br><span class="line">    to：即将进入的路由对象。</span><br><span class="line">    from：当前导航正要离开的路由对象。</span><br><span class="line">    在 afterEach 守卫中，我们可以添加逻辑来执行一些操作，例如记录页面访问日志或更新页面标题。</span><br></pre></td></tr></table></figure><h3 id="stores"><a href="#stores" class="headerlink" title="stores"></a>stores</h3><p>是用于管理应用状态的地方。它们提供了一种集中管理和共享状态的方式，使得不同组件之间可以方便地访问和修改状态。Pinia 是 Vue 的状态管理库之一，它提供了简单且强大的 API 来定义和使用 stores。<br>如上一个所示，userstore的创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const useStore = defineStore(&#x27;store&#x27;, () =&gt; &#123;</span><br><span class="line">const auth = reactive(&#123;</span><br><span class="line">  user:null</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  return &#123; auth&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要功能</span><br><span class="line">集中管理状态：</span><br><span class="line">stores 将应用的状态集中在一个地方，方便管理和维护。</span><br><span class="line">例如，用户的认证状态、应用的设置、购物车的内容等都可以存储在 stores 中。</span><br><span class="line">共享状态：</span><br><span class="line">通过 stores，不同的组件可以共享同一个状态。</span><br><span class="line">例如，用户登录后，多个组件都需要知道用户的登录状态，这时可以通过 stores 来实现状态共享。</span><br><span class="line">响应式状态：</span><br><span class="line">stores 中的状态是响应式的，当状态发生变化时，依赖该状态的组件会自动更新。</span><br><span class="line">例如，当购物车中的商品数量发生变化时，显示购物车内容的组件会自动更新。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>在使用main.js里面的作用</p><p>整体作用是创建并配置一个 Vue 应用，使用 Pinia 进行状态管理，使用 Vue Router 进行导航，并通过 axios 进行 HTTP 请求。最后，将应用挂载到指定的 DOM 元素上进行渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                            // 从 Vue 导入 createApp 函数</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">                             // 从 Pinia 导入 createPinia 函数</span><br><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">                              // 导入主应用组件</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">                            // 导入路由配置</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">                                // 导入 Element Plus 的样式文件</span><br><span class="line">import &#x27;element-plus/dist/index.css&#x27;</span><br><span class="line">                                // 导入 axios 库</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line"></span><br><span class="line">                             // 创建一个 Vue 应用实例</span><br><span class="line">const app = createApp(App)</span><br><span class="line">                                 // 设置 axios 的默认基础 URL</span><br><span class="line">axios.defaults.baseURL = &#x27;http://localhost:8091&#x27;</span><br><span class="line"></span><br><span class="line">                                    // 使用 Pinia 作为状态管理库</span><br><span class="line">app.use(createPinia())</span><br><span class="line">                            // 使用路由配置</span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line">                            // 挂载应用到指定的 DOM 元素上</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，上面挂载默认界面是App.Vue</p><p>拿着本实战来说APP.vue为根目录<br>他里面就存放一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>&lt;router-view&gt; </code>是一个占位符，表示路由匹配的组件将会在这里渲染。这样，当你导航到不同的路由时，<br>匹配的组件会在 App.vue 中的 <code>&lt;router-view&gt;</code>里面</p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>components 目录通常包含应用中可复用的、独立的 UI 组件。这些组件可以在多个地方使用，并且通常是较小的、功能单一的组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可复用性：这些组件可以在多个视图或其他组件中使用。</span><br><span class="line">独立性：每个组件通常只负责一个特定的功能或 UI 部分。</span><br><span class="line">粒度较小：组件通常是较小的 UI 单元，例如按钮、输入框、卡片等。</span><br></pre></td></tr></table></figure><p>这个很好理解，就是 子路由</p><h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>目录通常包含应用中的页面级组件。这些组件通常对应于路由，并且是较大的、包含多个子组件的组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">页面级别：这些组件通常对应于应用中的一个完整页面。</span><br><span class="line">包含子组件：视图组件通常包含多个子组件，组合成一个完整的页面。</span><br><span class="line">与路由关联：每个视图组件通常对应一个路由路径</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类，接口，构造方法详解</title>
      <link href="/2024/03/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/03/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h1><p>在 Java 语言中使用 abstract class 来定义抽象类，<br>抽象类不能被实例化，抽象类必须被继承，才能被使用。<br>一个类只能继承一个抽象类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String address, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructing an Employee&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Employee computePay&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mailCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mailing a check to &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + address + <span class="string">&quot; &quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String newAddress)</span> &#123;</span><br><span class="line">        address = newAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* 以下是不允许的，会引发错误 */</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;George W.&quot;</span>, <span class="string">&quot;Houston, TX&quot;</span>, <span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n Call mailCheck using Employee reference--&quot;</span>);</span><br><span class="line">        e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然它会报错，这就是抽象类，不能被实例化的例子。但是注意如果实例化继承它的类是可以用这个抽象类所有的方法的</p><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a><strong>继承抽象类</strong></h2><p>继承抽象类，用extend  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> salary; <span class="comment">//Annual salary</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Salary</span><span class="params">(String name, String address, <span class="type">int</span> number, <span class="type">double</span></span></span><br><span class="line"><span class="params">      salary)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">super</span>(name, address, number);</span><br><span class="line">       setSalary(salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mailCheck</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Within mailCheck of Salary class &quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;Mailing check to &quot;</span> + getName()</span><br><span class="line">       + <span class="string">&quot; with salary &quot;</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> newSalary)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(newSalary &gt;= <span class="number">0.0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          salary = newSalary;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Computing salary pay for &quot;</span> + getName());</span><br><span class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。<br>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Salary</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="string">&quot;Mohd Mohtashim&quot;</span>, <span class="string">&quot;Ambehta, UP&quot;</span>, <span class="number">3</span>, <span class="number">3600.00</span>);</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="string">&quot;John Adams&quot;</span>, <span class="string">&quot;Boston, MA&quot;</span>, <span class="number">2</span>, <span class="number">2400.00</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;Call mailCheck using Salary reference --&quot;</span>);</span><br><span class="line">      s.mailCheck();</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;\n Call mailCheck using Employee reference--&quot;</span>);</span><br><span class="line">      e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造方法在抽象类的应用"><a href="#构造方法在抽象类的应用" class="headerlink" title="构造方法在抽象类的应用"></a>构造方法在抽象类的应用</h3><p>接下来让我详细给你讲一讲，首先实例化Salary并命名为s注意这个地方传了四个参数这个地方用的就是构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Salary</span> <span class="params">(String name, String address, <span class="type">int</span> number, <span class="type">double</span></span></span><br><span class="line"><span class="params">     salary)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">super</span>(name, address, number);</span><br><span class="line">      setSalary(salary);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意 super(name, address, number); 是从父类继承来的。而setSalary(salary);是设置Salary的值。</p><h2 id="抽像方法"><a href="#抽像方法" class="headerlink" title="抽像方法"></a><strong>抽像方法</strong></h2><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意抽象类中有public abstract double computePay();这个就是抽象方法，它只有(),没有{}<br><strong>注意如果一个类包含抽象方法，那么该类必须是抽象类。<br>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</strong><br>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，<br>必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><h2 id="抽象总结"><a href="#抽象总结" class="headerlink" title="抽象总结"></a><strong>抽象总结</strong></h2><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h1><p>接口在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明<br>接口并不是类，类描述对象的属性和方法。接口则包含类要实现的方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。  </p><h2 id="接口与类的异同点"><a href="#接口与类的异同点" class="headerlink" title="接口与类的异同点"></a>接口与类的异同点</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><pre><code>一个接口可以有多个方法。接口文件保存在 .java 结尾的文件中，文件名使用接口名。接口的字节码文件保存在 .class 结尾的文件中。接口相应的字节码文件必须在与包名称相匹配的目录结构中</code></pre><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><pre><code>    接口不能被实例化    接口没有构造方法    接口中的所有方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。    接口不是要被继承而是要被实现    接口支持多继承</code></pre><h2 id="接口与抽象类的异同点"><a href="#接口与抽象类的异同点" class="headerlink" title="接口与抽象类的异同点"></a>接口与抽象类的异同点</h2><p>抽象类可以有抽象方法体，就是方法的具体功能，而接口中的方法不能<br>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。<br>一个类只能继承一个抽象类，而一个类却可以实现多个接口</p><h2 id="接口举例"><a href="#接口举例" class="headerlink" title="接口举例"></a>接口举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NameOfInterface</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//任何类型 final, static 字段</span></span><br><span class="line">   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。接口中的方法都是公有的。</code></pre><p>如下图代码 抽象方法的abstract被隐藏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>接口要实现它里面的所有方法否则，类必须声明为抽象的类。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面<br>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MammalInt</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">noOfLegs</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">MammalInt</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MammalInt</span>();</span><br><span class="line">m.eat();</span><br><span class="line">m.travel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写接口中声明的方法时，需要注意以下规则"><a href="#重写接口中声明的方法时，需要注意以下规则" class="headerlink" title="重写接口中声明的方法时，需要注意以下规则"></a>重写接口中声明的方法时，需要注意以下规则</h3><p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。<br>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。<br>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p><h3 id="在实现接口的时候，也要注意一些规则"><a href="#在实现接口的时候，也要注意一些规则" class="headerlink" title="在实现接口的时候，也要注意一些规则"></a>在实现接口的时候，也要注意一些规则</h3><p>一个类可以同时实现多个接口。<br>一个类只能继承一个类，但是能实现多个接口。<br>一个接口能继承另一个接口，这和类之间的继承比较相似。</p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>在Java中，类的多继承是不合法，但接口允许多继承。</p><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hockey</span> <span class="keyword">extends</span> <span class="title class_">Sports</span>, Event</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="构造方法的特点"><a href="#构造方法的特点" class="headerlink" title="构造方法的特点"></a>构造方法的特点</h2><pre><code>构造方法的名称必须与类名完全相同。构造方法没有返回类型，包括void。构造方法在创建对象时被调用，用于初始化对象。如果没有显式定义构造方法，默认会有一个无参构造方法。你可以重载构造方法，即定义多个具有不同参数列表的构造方法</code></pre><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象并调用构造方法进行初始化</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 使用无参构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>); <span class="comment">// 使用带参数的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法总的来说"><a href="#构造方法总的来说" class="headerlink" title="构造方法总的来说"></a>构造方法总的来说</h2><p>构造方法的主要作用是初始化对象的状态，也就是为对象的实例变量赋初值。<br>构造方法可以被子类继承和调用，用于初始化对象的状态。当一个类继承自抽象类时，在创建对象实例时会调用父类的构造方法来初始化父类的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白安装git和Hexo</title>
      <link href="/2024/03/21/%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85git%E5%92%8CHexo/"/>
      <url>/2024/03/21/%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85git%E5%92%8CHexo/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h1><p>你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>比如我的博客文件都存放在D:\Study\MyBlog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。</p><p>定位到该目录下，输入<a name="_hlk161739177"></a>npm install -g hexo-cli安装Hexo。               </p><h2 id="为什么要在这个文件夹下面来创建hexo"><a href="#为什么要在这个文件夹下面来创建hexo" class="headerlink" title="为什么要在这个文件夹下面来创建hexo"></a>为什么要在这个文件夹下面来创建hexo</h2><p><strong>全局安装只是确保你可以在任何地方使用 Hexo 的命令行界面，但是在实际使用 Hexo 时，你仍然需要在你的博客文件夹中进行相关操作。</strong></p><p><strong>定位到文件夹下的目的是为了告诉 Hexo 在哪个文件夹中生成博客网站。Hexo 是基于文件夹的静态网站生成器，它会根据当前所在的文件夹中的配置文件和内容来生成博客网站。因此，为了让 Hexo 正确地生成你的博客，你需要先进入存放博客文件的文件夹，在该文件夹中执行 Hexo 相关的命令，从而确保博客内容可被正确生成和发布。</strong></p><p><strong>总结起来，全局安装 Hexo 的命令行界面只是确保你可以在全局的任何地方使用 Hexo 命令，而定位到文件夹下是为了在指定的博客文件夹中进行具体的 Hexo 操作，以生成和管理博客网站。</strong></p><h2 id="npm-install-g-hexo-cli安装Hexo报错。"><a href="#npm-install-g-hexo-cli安装Hexo报错。" class="headerlink" title="npm install -g hexo-cli安装Hexo报错。"></a><strong>npm install -g hexo-cli安装Hexo报错。</strong></h2><p><strong>$ npm install -g hexo-cli</strong></p><p><strong>npm ERR! code EPERM</strong></p><p><strong>npm ERR! syscall mkdir</strong></p><p><strong>npm ERR! path D:\nodejs\node_cache\_cacache</strong></p><p><strong>npm ERR! errno -4048</strong></p><p><strong>npm ERR! Error: EPERM: operation not permitted, mkdir ‘D:\nodejs\node_cache\_cacache’</strong></p><p><strong>npm ERR!  [Error: EPERM: operation not permitted, mkdir ‘D:\nodejs\node_cache\_cacache’] {</strong></p><p><strong>npm ERR!   errno: -4048,</strong></p><p><strong>npm ERR!   code: ‘EPERM’,</strong></p><p><strong>npm ERR!   syscall: ‘mkdir’,</strong></p><p><strong>npm ERR!   path: ‘D:\nodejs\<a name="_hlk161739480"></a>node_cache\_cacache’</strong></p><p><strong>npm ERR! }</strong></p><p><strong>npm ERR!</strong></p><p><strong>npm ERR! The operation was rejected by your operating system.</strong></p><p><strong>npm ERR! It’s possible that the file was already in use (by a text editor or antivirus),</strong></p><p><strong>npm ERR! or that you lack permissions to access it.</strong></p><p><strong>npm ERR!</strong></p><p><strong>npm ERR! If you believe this might be a permissions issue, please double-check the</strong></p><p><strong>npm ERR! permissions of the file and its containing directories, or try running</strong></p><p><strong>npm ERR! the command again as root&#x2F;Administrator.</strong></p><p><strong>npm ERR! Log files were not written due to an error writing to the directory: D:\nodejs\node_cache\_logs</strong></p><p>npm ERR! You can rerun the command with <code>--loglevel=verbose</code> to see the logs in your terminal</p><p><a name="_hlk161739652"></a></p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p><strong>意思是权限不够</strong></p><p>这个错误通常是由于权限问题或者其他进程正在使用相关文件所导致的。有几种可能的解决方法：</p><p>1. 以管理员身份运行命令提示符：右键点击命令提示符符号，然后选择“以管理员身份运行”选项。接下来再尝试运行 <code>npm install -g hexo-cli</code> 命令看是否能够解决问题。</p><p>2. 使用 <code>sudo</code> 运行命令（仅适用于 macOS 和 Linux 用户）：在命令前添加 <code>sudo</code>，即 <code>sudo npm install -g hexo-cli</code>。这将使用管理员权限来运行命令。</p><p>3. 检查文件权限：确保你具有对所涉及的目录和文件的写入权限，以及没有其他进程正在使用文件。特别是要注意杀毒软件或防火墙等安全软件是否导致了文件被锁定。</p><p>请尝试这些方法来解决权限问题，并让我知道是否成功。如果问题仍然存在，请提供更多详细信息，以便我能够提供更准确的建议。</p><h3 id="解决方法及结果"><a href="#解决方法及结果" class="headerlink" title="解决方法及结果"></a><strong>解决方法及结果</strong></h3><p>修改了node_cache文件夹的权限成功部署Hexo</p><p><strong>$ npm install -g hexo-cli</strong></p><p><strong>added 54 packages in 7s</strong></p><p><strong>15 packages are looking for funding</strong></p><p><code>  </code><strong>run <code>npm fund</code> for details</strong></p><p><strong>npm notice</strong></p><p><strong>npm notice New minor version of npm available! 10.2.4 -&gt; 10.5.0</strong></p><p><strong>npm notice Changelog: <a href="https://github.com/npm/cli/releases/tag/v10.5.0">https://github.com/npm/cli/releases/tag/v10.5.0</a></strong></p><p><strong>npm notice Run <code>npm install -g npm@10.5.0</code> to update!</strong></p><p><strong>npm notice</strong></p><p>**</p><h3 id="输入-hexo-v找不到"><a href="#输入-hexo-v找不到" class="headerlink" title="输入 hexo -v找不到"></a><strong>输入 hexo -v找不到</strong></h3><p>$ hexo -v</p><p>bash: hexo: command not found</p><p>发现可能是npm的环境变量未设置，我也是服了</p><h3 id="成功配置找到hexo"><a href="#成功配置找到hexo" class="headerlink" title="成功配置找到hexo"></a><strong>成功配置找到hexo</strong></h3><p>原因我在node.js中修改了配置文件并没有在环境变量中设置它</p><h1 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a><strong>初始化hexo</strong></h1><p>$ hexo init</p><p>INFO  Cloning hexo-starter <a href="https://github.com/hexojs/hexo-starter.git">https://github.com/hexojs/hexo-starter.git</a></p><p>INFO  Install dependencies</p><p>INFO  Start blogging with Hexo!</p><h1 id="hexo-g-生成静态文件-hexo-s启动服务端"><a href="#hexo-g-生成静态文件-hexo-s启动服务端" class="headerlink" title="hexo-g 生成静态文件 hexo-s启动服务端"></a><strong>hexo-g 生成静态文件 hexo-s启动服务端</strong></h1><p>hexo g其中的g代表generate生成静态文件</p><p>其中的hexo-s中service是服务端</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Git设置用户名和邮箱"><a href="#Git设置用户名和邮箱" class="headerlink" title="Git设置用户名和邮箱"></a><strong>Git设置用户名和邮箱</strong></h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h2><p>是为了在传输到githup上区分谁传的</p><p>langye@LAPTOP-D48FO80D MINGW64 &#x2F;d&#x2F;MyBlog</p><p><a name="_hlk161758030"></a>$ git config –global user.name “langye123”                                     </p><p>langye@LAPTOP-D48FO80D MINGW64 &#x2F;d&#x2F;MyBlog</p><p>$ git config –global user.email “<a href="mailto:&#x32;&#52;&#x30;&#x31;&#48;&#x30;&#x34;&#55;&#x37;&#54;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;">&#x32;&#52;&#x30;&#x31;&#48;&#x30;&#x34;&#55;&#x37;&#54;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;</a>“</p><p>langye@LAPTOP-D48FO80D MINGW64 &#x2F;d&#x2F;MyBlog</p><p>$ git config –global –list</p><p>user.name&#x3D;langye123</p><p>user.email&#x3D;<a href="mailto:&#50;&#x34;&#48;&#x31;&#x30;&#48;&#52;&#55;&#55;&#x36;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#50;&#x34;&#48;&#x31;&#x30;&#48;&#52;&#55;&#55;&#x36;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></p><h2 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a><strong>详细讲解</strong></h2><p>$ git config –global user.name “langye123” 设置用户名</p><p>$ git config –global user.email “邮箱”</p><p>$ git config –global –list 展示是否成功</p><p>生成密钥</p><h1 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a><strong>生成密钥</strong></h1><p>$ ssh-keygen -t rsa -C “填邮箱地址”</p><p>&#96;</p><h2 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a><strong>两种方法</strong></h2><p>ssh-keygen -t rsa<code>和</code>ssh-keygen -t rsa -C “GitHub 邮箱”<code>之间的区别在于后者使用了</code>-C&#96; 选项来添加注释信息，以便将来能够识别该密钥是用于什么用途。</p><p>具体而言，<code>-C &quot;GitHub 邮箱&quot;</code> 中的邮件地址可以帮助你在管理多个密钥对时更容易地辨识每个密钥对所属的身份。这样可以让你清晰地知道每个密钥对是用于哪个服务或者哪个身份的认证。 </p><p>而如果只是使用<code>ssh-keygen -t rsa</code>，生成的密钥对就没有附带任何注释信息。这可能会使得在管理多个密钥对时变得不够清晰，因为无法通过注释来区分不同的密钥对所属的身份。</p><p><strong>用于提交的时候识别是不是本人的后续有一次报错因为把自己的邮箱隐藏了但是</strong></p><p><strong>$ ssh-keygen -t rsa -C “填邮箱地址”</strong></p><p><strong>填的还是它</strong></p><h1 id="看看是否连接到Githup"><a href="#看看是否连接到Githup" class="headerlink" title="看看是否连接到Githup"></a><strong>看看是否连接到Githup</strong></h1><p>$ ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;</a></p><p>The authenticity of host ‘github.com (20.205.243.166)’ can’t be established.</p><p>ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF&#x2F;zLDA0zPMSvHdkr4UvCOqU.</p><p>This key is not known by any other names.</p><p>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes</p><p>Warning: Permanently added ‘github.com’ (ED25519) to the list of known hosts.</p><p>Hi langye123! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>成功</p><h1 id="config-yml目录下修改配置"><a href="#config-yml目录下修改配置" class="headerlink" title="_config.yml目录下修改配置"></a><strong>_config.yml目录下修改配置</strong></h1><p><a name="_hlk161761804"></a>_config.yml目录下修改配置<br>deploy:<br><code>  </code>type: git<br><code>  </code>repo: <a href="https://github.com/langye123/langye123.github.io.git">https://github.com/langye123/langye123.github.io.git</a><br><code>  </code>branch: main</p><p>类型：git</p><p>仓库：<a href="https://github.com/langye123/langye123.github.io.git">https://github.com/langye123/langye123.github.io.git</a></p><p>分支：main</p><p>用http会造成登录github账号</p><p>改成这个了之前用Http报错。</p><p>deploy:<br><code>  </code>type: git<br><code>  </code>repo: <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:langye123&#x2F;langye123.github.io.git<br><code>  </code>branch: main</p><p>这段文字中包含了关于 Git 仓库的信息，指明了仓库的类型是 Git，仓库地址为 <a href="https://github.com/langye123/langye123.github.io.git%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E6%94%AF%E6%98%AF">https://github.com/langye123/langye123.github.io.git，使用的分支是</a> main。如果需要进一步解释或有其他问题，请随时告诉我！</p><h1 id="安装-deploy-git。"><a href="#安装-deploy-git。" class="headerlink" title="安装 deploy-git。"></a><strong>安装 deploy-git。</strong></h1><p>安装 deploy-git ，也就是部署的命令，这样你才能用命令部署到 GitHub。</p><p>npm install hexo-deployer-git –save 这条命令是用来在 Hexo 静态网站生成器中安装并保存 hexo-deployer-git 插件的。</p><p>具体来说，hexo-deployer-git 是 Hexo 提供的一个部署插件，它允许你将生成的静态网站文件直接部署到 Git 仓库中，以便实现自动部署并发布网站的功能。一旦安装了这个插件，你就可以使用 Hexo 命令来将生成的静态网站文件快速地推送到指定的 Git 仓库中，方便地更新和管理你的网站内容。</p><p>成功</p><p>$ npm install hexo-deployer-git –save</p><p>added 9 packages, and audited 250 packages in 4s</p><p>29 packages are looking for funding</p><p>run <code>npm fund</code> for details</p><p>found 0 vulnerabilities</p><h1 id="部署快捷键"><a href="#部署快捷键" class="headerlink" title="部署快捷键"></a><strong>部署快捷键</strong></h1><p>exo clean 清除了你之前生成的东西，也可以不加。 </p><p>hexo generate 顾名思义，生成静态文章，可以用 hexo g 缩写 ，</p><p>hexo deploy 部署文章，可以用 hexo d 缩写</p><h1 id="npm-i-hexo-theme-butterfly"><a href="#npm-i-hexo-theme-butterfly" class="headerlink" title="$ npm i hexo-theme-butterfly"></a><strong>$ npm i hexo-theme-butterfly</strong></h1><p>用npm创建butterfly主题定制</p><p>$ npm i hexo-theme-butterfly</p><p>added 46 packages, and audited 296 packages in 11s</p><p>38 packages are looking for funding</p><p><code>  </code>run <code>npm fund</code> for details</p><p>found 0 vulnerabilities</p><h1 id="安装-pug-以及-stylus-的渲染器"><a href="#安装-pug-以及-stylus-的渲染器" class="headerlink" title="安装 pug 以及 stylus 的渲染器"></a><strong>安装 pug 以及 stylus 的渲染器</strong></h1><p>npm install hexo-renderer-pug hexo-renderer-stylus –save</p><p>。</p><h2 id="为啥安装它"><a href="#为啥安装它" class="headerlink" title="为啥安装它"></a><strong>为啥安装它</strong></h2><p>Pug 和 Stylus 是两种用于网页开发的预处理器，它们分别用于 HTML 模板和 CSS 样式表的渲染和生成。</p><p>1. Pug（之前被称为 Jade）：Pug 是一种基于缩进的模板引擎，用于简化 HTML 文档的编写。通过使用 Pug，您可以以更简洁、结构化的方式编写 HTML，并且可以嵌入 JavaScript 代码以及动态生成内容。Pug 文件需要经过渲染处理后才能生成最终的 HTML 页面。</p><p>2. Stylus：Stylus 是一种 CSS 预处理器，它允许您以更灵活、更简洁的方式编写 CSS 样式表。通过使用 Stylus，您可以使用变量、嵌套规则、混合（Mixin）等功能来提高 CSS 的可维护性和可读性。Stylus 文件也需要经过渲染处理后才能生成最终的 CSS 样式表。</p><p>在 Node.js 环境中，通常会使用相关的渲染器（如 <code>pug</code> 和 <code>stylus</code> 模块），来将 Pug 和 Stylus 文件渲染为最终的 HTML 和 CSS 文件，以便在网页中使用。这些渲染器会将 Pug 文件转换为标准的 HTML 文件，将 Stylus 文件转换为标准的 CSS 文件，从而方便在网站中使用这些预处理器所生成的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>你好github</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/19/hello-world/"/>
      <url>/2024/03/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
