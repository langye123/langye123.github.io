<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实战2前端_稻草人vue3</title>
      <link href="/2024/07/17/%E5%AE%9E%E6%88%982%E5%89%8D%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BAvue3/"/>
      <url>/2024/07/17/%E5%AE%9E%E6%88%982%E5%89%8D%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BAvue3/</url>
      
        <content type="html"><![CDATA[<h2 id="导入环境，初始化一个vue3项目"><a href="#导入环境，初始化一个vue3项目" class="headerlink" title="导入环境，初始化一个vue3项目"></a>导入环境，初始化一个vue3项目</h2><p>利用控制台，注意不是idea控制台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 10.0.22631.3737]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">D:\cheng shi xi tong\idea\ssm\实战springboot3\实战3_稻草人\daocao_study&gt;npm create vue</span><br><span class="line">Need to install the following packages:</span><br><span class="line">create-vue@3.10.4</span><br><span class="line">Ok to proceed? (y) y</span><br><span class="line"></span><br><span class="line">Vue.js - The Progressive JavaScript Framework</span><br><span class="line"></span><br><span class="line">√ 请输入项目名称： ... daocao_admin_page</span><br><span class="line">√ 是否使用 TypeScript 语法？ ... 否 / 是</span><br><span class="line">√ 是否启用 JSX 支持？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vue Router 进行单页面应用开发？ ... 否 / 是</span><br><span class="line">√ 是否引入 Pinia 用于状态管理？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vitest 用于单元测试？ ... 否 / 是</span><br><span class="line">√ 是否要引入一款端到端（End to End）测试工具？ » 不需要</span><br><span class="line">√ 是否引入 ESLint 用于代码质量检测？ ... 否 / 是</span><br><span class="line">√ 是否引入 Vue DevTools 7 扩展用于调试? (试验阶段) ... 否 / 是</span><br><span class="line"></span><br><span class="line">正在初始化项目 D:\cheng shi xi tong\idea\ssm\实战springboot3\实战3_稻草人\daocao_study\daocao_admin_page...</span><br><span class="line"></span><br><span class="line">项目初始化完成，可执行以下命令：</span><br><span class="line"></span><br><span class="line">  cd daocao_admin_page</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前端VsCode插件导入安装"><a href="#前端VsCode插件导入安装" class="headerlink" title="前端VsCode插件导入安装"></a>前端VsCode插件导入安装</h2><ol><li>Auto Close Tag：自动为HTML&#x2F;XML标签添加闭合标签1。</li><li>Vue VSCode Snippets：提供Vue.js开发的代码片段，提升开发效率2。</li><li>Vue Peek：允许在Vue单文件组件中快速跳转或预览定义3。</li><li>Image preview：在代码编辑器中预览图像4。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战2_稻草人后端</title>
      <link href="/2024/07/17/%E5%AE%9E%E6%88%982%E5%90%8E%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BA/"/>
      <url>/2024/07/17/%E5%AE%9E%E6%88%982%E5%90%8E%E7%AB%AF_%E7%A8%BB%E8%8D%89%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="引入Mysql不是有mysql，本地还是要安装mysql"><a href="#引入Mysql不是有mysql，本地还是要安装mysql" class="headerlink" title="引入Mysql不是有mysql，本地还是要安装mysql"></a>引入Mysql不是有mysql，本地还是要安装mysql</h2><h2 id="遇见了一个错误，不能很好跑起来SpringbootApplication"><a href="#遇见了一个错误，不能很好跑起来SpringbootApplication" class="headerlink" title="遇见了一个错误，不能很好跑起来SpringbootApplication"></a>遇见了一个错误，不能很好跑起来SpringbootApplication</h2><p>解决这个问题，或者可以用spring生成器进行操作。<br>下面是放在dependencyManagement中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">依赖项放在 dependencyManagement 部分中，这样做的好处是可以集中管理依赖项的版本，并在子模块中引用这些依赖项时不需要重复指定版本号。这种方式可以减少版本冲突和依赖管理的复杂性。</span><br><span class="line"></span><br><span class="line">以下是一些可能的原因，解释为什么这样做解决了你的问题：</span><br><span class="line"></span><br><span class="line">集中管理依赖版本：dependencyManagement 部分允许你在一个地方定义所有依赖项的版本，这样在子模块中引用这些依赖项时，不需要再指定版本号，减少了版本冲突的可能性。</span><br><span class="line">正确的依赖范围：将 spring-boot-dependencies 放在 dependencyManagement 中，并使用 import scope 是正确的做法。这确保了 Spring Boot 的依赖项版本管理能够正确应用到你的项目中。</span><br><span class="line">避免重复定义：通过 dependencyManagement，你可以避免在多个模块中重复定义相同的依赖项和版本号，这样可以减少错误和不一致性。</span><br><span class="line">传递依赖项：Maven 会自动处理传递依赖项，确保所有必要的库都被正确下载和包含在项目中。</span><br></pre></td></tr></table></figure><h2 id="idea插件"><a href="#idea插件" class="headerlink" title="idea插件"></a>idea插件</h2><p><code>CodeGlance pro: 代码缩略图</code><br><code>GenerateAllSetter 一键调用一个对象的所有的set方法,get方法等 在方法上生成两个对象的转换</code></p><h2 id="创建gitee仓库"><a href="#创建gitee仓库" class="headerlink" title="创建gitee仓库"></a>创建gitee仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">快速设置— 如果你知道该怎么操作，直接使用下面的地址</span><br><span class="line"> </span><br><span class="line">git@gitee.com:langye521/daocao_study.git</span><br><span class="line">我们强烈建议所有的git仓库都有一个README, LICENSE, .gitignore文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">简易的命令行入门教程:</span><br><span class="line">Git 全局设置:</span><br><span class="line"></span><br><span class="line">            git config --global user.name &quot;langye521&quot;</span><br><span class="line">            git config --global user.email &quot;2401004776@qq.com&quot;</span><br><span class="line">创建 git 仓库:</span><br><span class="line"></span><br><span class="line">            mkdir daocao_study</span><br><span class="line">            cd daocao_study</span><br><span class="line">            git init </span><br><span class="line">            touch README.md</span><br><span class="line">            git add README.md</span><br><span class="line">            git commit -m &quot;first commit&quot;</span><br><span class="line">            git remote add origin git@gitee.com:langye521/daocao_study.git</span><br><span class="line">            git push -u origin &quot;master&quot;</span><br><span class="line">已有仓库?</span><br><span class="line"></span><br><span class="line">            cd existing_git_repo</span><br><span class="line">            git remote add origin git@gitee.com:langye521/daocao_study.git</span><br><span class="line">            git push -u origin &quot;master&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot3 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh公钥更改，删除，添加</title>
      <link href="/2024/07/14/ssh%E5%85%AC%E9%92%A5%E6%9B%B4%E6%94%B9%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E6%B7%BB%E5%8A%A0/"/>
      <url>/2024/07/14/ssh%E5%85%AC%E9%92%A5%E6%9B%B4%E6%94%B9%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E6%B7%BB%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>登录服务器：使用 SSH 客户端登录到服务器。<br><code>ssh username@server_ip_address</code></p><p>找到公钥文件：在服务器上，SSH 公钥通常存储在用户的 .ssh 目录下。<br><code>cd ~/.ssh</code></p><p>查看公钥文件：列出当前存在的公钥文件。<br><code>ls</code><br>指出当前文件夹下的所有文件或文件夹<br>这个地方会显示公钥列表<br>打开 authorized_keys 文件：<br><code>vim ~/.ssh/authorized_keys</code></p><p>进入插入模式：在 Vim 中，按 i 键进入插入模式。<br>删除不需要的公钥：使用箭头键移动光标到需要删除的公钥行，然后按 dd 删除整行。<br>保存并退出：<br>按 Esc 键退出插入模式。<br>输入 :wq 保存并退出 Vim。<br>重新启动 SSH 服务（可选）：如果你修改了 authorized_keys 文件，可以通过重启 SSH 服务使更改生效。<br><code>sudo service ssh restart</code></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客问题汇总</title>
      <link href="/2024/07/14/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2024/07/14/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ol><li>标签问题，感觉标签或者分类不是特别合适，换一下，导致部署出来旧的分类或者标签还在</li></ol><p>解决： 去public，文件夹下把对应的旧的文件夹删掉。记住用 hexo clean 多试几遍<br>2. 公钥问题登不上去，github，把博客迁移到自己的服务器上，想着githun上面也不能荒废，想着往上面再传一下，发现传不上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub                    查看自己的公钥看看是不是变了，结果没有变</span><br><span class="line">ssh -T -ai ~/.ssh/id_rsa git@github.com  查看公钥被github上面哪一个用户或者仓库使用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人梯子搭建指南</title>
      <link href="/2024/07/13/%E4%B8%AA%E4%BA%BA%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/07/13/%E4%B8%AA%E4%BA%BA%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前景导入"><a href="#前景导入" class="headerlink" title="前景导入"></a>前景导入</h2><p>身为一个优秀的程序员，只会去网上用其他人的机场，是不是有点low,还不方便，害怕他随时跑路，本文记录一下自己梯子过程</p><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><p>1.不要用阿里云香港服务器，本人第一次用阿里云香港服务器，运行了一小会，正在怯怯自喜，直接ip被封了，还好是弹性公网IP</p><p>2.网上随便找一个，香港服务器，注意辨别，这里就不在推荐</p><h2 id="直接上才艺"><a href="#直接上才艺" class="headerlink" title="直接上才艺"></a>直接上才艺</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. **安装 `python-pip` 和 `shadowsocks`**：</span><br><span class="line"></span><br><span class="line">    ```sh</span><br><span class="line">    sudo yum install python-pip</span><br><span class="line">    sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><ol start="2"><li><p>**创建并编辑 <code>/etc/shadowsocks.json</code>**：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure></li><li><p><strong>将格式化后的内容粘贴到 <code>shadowsocks.json</code> 文件中</strong>：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">8388</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dd531322!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动 <code>shadowsocks</code> 服务</strong>：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></li><li><p><strong>使用客户端连接</strong>：</p><p> 确保 U 盘内的 <code>shadowsocks</code> 客户端版本为 4.0.9，并输入相应的配置信息：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server: 0.0.0.0</span><br><span class="line">Server Port: 8388</span><br><span class="line">Local Address: 127.0.0.1</span><br><span class="line">Local Port: 1080</span><br><span class="line">Password: Dd531322!</span><br><span class="line">Encryption Method: aes-256-cfb</span><br></pre></td></tr></table></figure><p> 配置完成后即可通过客户端使用代理服务。</p></li><li><p><strong>防火墙设置</strong>：</p><p> 关闭本地防火墙并打开云防火墙，以确保服务可以正常连接：</p><p> 停止并禁用防火墙：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p> 请根据云防火墙的文档配置相应的规则，确保 TCP 端口 8388 (服务器端口) 和 1080 (本地代理端口) 开放。</p></li></ol><p>注意：关闭防火墙可能会造成安全风险，请根据实际情况调整防火墙规则，确保只有被信任的流量被允许通过。</p><pre><code>## 常见的问题总结使用`ps -ef | grep ssserver`查看所有ssserver进程，可以查看shadowswork是否运行使用`sudo kill -9 29644`强制终结shadowswork 使用了Linux中的&quot;sudo&quot;来提升权限，并使用&quot;kill&quot;命令终止进程，&quot;-9&quot;是一个信号，表示强制终止该进程。&quot;29644&quot;是要终止的进程的进程号。使用` ps aux`查看所有进程信息使用`firewall-cmd --zone=public --list-ports`查看防火墙所有打开的端口使用`sudo iptables -L -v -n` 显示当前配置的所有防火墙规则，包括哪些端口和IP地址被允许或阻止另外进行`vim`操作的时候，按i键，进入编辑模式，按esc键退出编辑模式，按`:wq`保存并退出，按`:q`键退出不保存</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迁移自己博客，从github到自己的服务器</title>
      <link href="/2024/07/13/%E8%BF%81%E7%A7%BBgithup%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/07/13/%E8%BF%81%E7%A7%BBgithup%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>前提自己系统是centox，登录到自己的服务器上，创建一个新的用户，<code>sudo adduser boke</code></p><ol><li>在服务器上安装必要的软件：<br>安装 Git 和 Nginx：<br><code>sudo apt install git</code><br>  <code>sudo apt install nginx</code><br><strong>注意在第二步的时候自己配置nginx完全不行，用的宝塔控制页面进行安装的，最后成功了</strong></li><li>配置 Nginx：<br>修改 Nginx 的默认配置文件（通常位于 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default），将博客文件放到 &#x2F;var&#x2F;www&#x2F;html 目录下。<br>注意：我的nginx在 <code>www/server/nginx/conf</code><br>打开命令配置<code>sudo vi /www/server/nginx/conf/nginx.conf</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在 http 块中添加一个新的 server 块来配置你的博客目录 /var/www/blog。你可以在 http 块的末尾添加以下内容：</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 自己的ip或者域名;</span><br><span class="line"></span><br><span class="line">    root /var/www/blog;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log /www/wwwlogs/yourblog_access.log;</span><br><span class="line">    error_log /www/wwwlogs/yourblog_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server 块是 Nginx 配置文件中的一个部分，用于定义不同的虚拟主机配置。每个 server 块可以配置一个独立的站点或服务。你现有的配置中已经有一个 server 块用于 phpmyadmin，我们需要添加另一个 server 块来配置你的博客站点。</span><br><span class="line"></span><br><span class="line">为什么需要多个 server 块？</span><br><span class="line">不同的服务：每个 server 块可以配置不同的服务。例如，一个用于 phpmyadmin，另一个用于你的博客。</span><br><span class="line">不同的域名或端口：每个 server 块可以监听不同的域名或端口。例如，一个监听 phpmyadmin 的端口 888，另一个监听你的博客的端口 80。</span><br><span class="line">独立配置：每个 server 块可以有独立的配置，例如根目录、日志文件、错误页面等。</span><br></pre></td></tr></table></figure><p>   重新加载 Nginx 配置：<br>   <code>sudo service nginx reload</code><br>3. 创建 Git 裸库：<br>   在服务器上创建一个 Git 裸库，用于保存博客文件：<br>   cd ~<br>   git init –bare blog.git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. `cd ~`: 这个命令表示切换到用户的家目录（`~` 是用户的主目录的简写），也就是登录用户默认的起始位置。</span><br><span class="line"></span><br><span class="line">`git init --bare blog.git`: 这是初始化一个新的 Git 仓库。`git init` 是创建一个新的 Git 项目的基本命令，而 `--bare` 参数意味着创建的是一个“裸”仓库，也称为轻量级仓库。这种类型的仓库不包含工作目录，主要用于远程存储库，</span><br><span class="line">如 GitHub、GitLab 等。`blog.git` 是你想要创建的 Git 仓库的名称，用于存放你的博客项目的版本控制信息。</span><br></pre></td></tr></table></figure><ol start="4"><li>配置 Git Hooks：<br>使用 Git 的 post-receive 钩子自动将最新内容同步到网站根目录：<br><code>vim ~/blog.git/hooks/post-receive</code><br>在文件中添加以下内容：<br>#!&#x2F;bin&#x2F;sh<br>git –work-tree&#x3D;&#x2F;var&#x2F;www&#x2F;html –git-dir&#x3D;~&#x2F;blog.git checkout -f<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=/var/www/blog --git-dir=/home/your_username/blog.git checkout -f</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. **`git --work-tree=/var/www/blog`**: 这部分指定 Git 的工作目录（Working Directory）为 `/var/www/blog`。这意味着所有与 Git 相关的文件操作都会在这个目录下进行。</span><br><span class="line"></span><br><span class="line">2. **`--git-dir=/home/boke/blog.git`**: 这个选项指出 Git 的仓库目录（Repository Directory）在用户 `boke` 的主目录下，即 `/home/boke/blog.git`。这通常指的是仓库的元数据（比如 `.git` 文件夹）存储的位置。</span><br><span class="line"></span><br><span class="line">3. **`checkout -f`**: 这个命令用于将工作目录 `/var/www/blog` 切换到与 `~/blog.git` 仓库关联的某个分支，或者强制性地恢复到特定的提交。`-f` 参数意味着如果存在未提交的更改，会丢弃这些更改以获取仓库的最新状态。</span><br><span class="line"></span><br><span class="line">整体来说，这个脚本的作用是将 `/var/www/blog` 目录的内容更新到与 `~/blog.git` 仓库中的最新提交或特定分支状态，通常用于远程仓库的自动化部署或同步。需要注意的是，如果 `/var/www/blog` 中有未提交的本地更改，使用 `-f` 参数可能会丢失这些更改，所以在使用时要确保没有意外的数据冲突。</span><br></pre></td></tr></table></figure>保存并赋予执行权限：</li></ol><p>  <code> chmod +x ~/blog.git/hooks/post-receive</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在这个上下文中，`~/blog.git/hooks/post-receive` 是一个位于 `hooks` 目录下的文件，通常在 Git 仓库中，`post-receive` 钩子文件是用来在接收远程仓库的推送时自动执行的脚本。`+x` 操作会赋予这个文件执行权限，使得系统允许其他用户（不仅仅是拥有者）可以通过运行这个文件来执行其中的命令。</span><br><span class="line"></span><br><span class="line">如果你之前编辑了 `post-receive` 文件并且想要使其能够在接收到远程推送时自动运行，那么设置执行权限是必要的。因为 Git 自动调用钩子文件，如果没有执行权限，Git 就无法运行这个脚本来完成相应的操作，比如更新服务器上的文件、触发构建等。</span><br></pre></td></tr></table></figure><p><strong>注意刚开始我又重新设置了一个角色，导致上一个命令不能正确赋予权限，我又重新到管理员的账号，执行了这个命令，注意把用户命令也加上<code>chmod +x /home/your_username/blog.git/hooks/post-receive </code></strong><br>5. 配置本地 Hexo 部署：<br>   打开 Hexo 博客根目录下的 _config.yml 文件，找到 deploy 部分并修改：<br>   deploy:<br>   type: git<br>   repository: ssh:&#x2F;&#x2F;user@your_server_ip:~&#x2F;blog.git<br>   branch: master<br>   执行以下命令将博客部署到服务器：<br>注意命令的用户名，和服务器地址要改。<br>   hexo clean<br>   hexo generate<br>   hexo deploy<br>6. 设置免密码登录：<br>   在本地生成 SSH 密钥对（如果还没有）：<br>   <code>ssh-keygen -t rsa</code><br>   将公钥上传到服务器：<br>  <code> ssh-copy-id user@your_server_ip</code><br>检查用户名公钥<br>   <code>cat ~/.ssh/authorized_keys</code></p><p>注意上传成功之后要在放行一下ssh规则</p><p><strong>这个地方部署ssl证书也就是tls证书</strong></p><p>首先找到安装nginx的默认目录可以用<code>nginx -t</code><br>当然对于你来说，你已经知道路径在哪，第一创建一个存放ssl证书的key和pem的地方，你存放的地方为<code>/www/server/nginx/conf</code><br>然后打开<code>sudo vi /www/server/nginx/conf/nginx.conf</code>进行编辑添加下面<br>内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line"></span><br><span class="line">    root /var/www/blog;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/cert/langye.xyz.pem;</span><br><span class="line">    ssl_certificate_key /path/to/cert/langye.xyz.key;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log /www/wwwlogs/yourblog_access.log;</span><br><span class="line">    error_log /www/wwwlogs/yourblog_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将端口钻发到443端口https路径<br>下面是详细解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nginx</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#### 解释：</span><br><span class="line">- `listen 80;`：告诉Nginx监听服务器的80端口，即默认的HTTP端口。</span><br><span class="line">- `server_name langye.xyz;`：指定服务器的域名为`langye.xyz`。</span><br><span class="line">- `return 301 https://$host$request_uri;`：这个指令会把所有通过HTTP发过来的请求重定向（301重定向）到对应的HTTPS地址。301状态码表示永久重定向。</span><br><span class="line"></span><br><span class="line">这个部分的配置主要是确保任何访问`http://langye.xyz`的请求都被安全地重定向到`https://langye.xyz`，让访问更加安全。</span><br><span class="line"></span><br><span class="line">### 第二段：</span><br><span class="line">```nginx</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name langye.xyz;</span><br><span class="line"></span><br><span class="line">    root /var/www/blog;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/cert/langye.xyz.pem;  ssl证书</span><br><span class="line">    ssl_certificate_key /path/to/cert/langye.xyz.key; 密钥</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log /www/wwwlogs/yourblog_access.log;</span><br><span class="line">    error_log /www/wwwlogs/yourblog_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>listen 443 ssl;</code>：告诉Nginx监听服务器的443端口，开启SSL（即HTTPS）。</li><li><code>server_name langye.xyz;</code>：指定服务器的域名为<code>langye.xyz</code>。</li><li><code>root /var/www/blog;</code>：设置网站的根目录为<code>/var/www/blog</code>，即静态文件的位置。</li><li><code>index index.html index.htm;</code>：指定默认的索引文件为<code>index.html</code>或者<code>index.htm</code>，如果访问的是目录，它会寻找这些文件来显示。</li></ul><h5 id="SSL配置："><a href="#SSL配置：" class="headerlink" title="SSL配置："></a>SSL配置：</h5><ul><li><code>ssl_certificate /path/to/cert/langye.xyz.pem;</code>：指定SSL证书文件的位置。</li><li><code>ssl_certificate_key /path/to/cert/langye.xyz.key;</code>：指定SSL证书密钥文件的位置。</li><li><code>ssl_protocols TLSv1.2 TLSv1.3;</code>：指定允许的SSL&#x2F;TLS协议版本。这里设置了TLS 1.2和TLS 1.3。</li><li><code>ssl_ciphers HIGH:!aNULL:!MD5;</code>：指定使用的加密算法。这一行过滤掉了一些低强度和不安全的算法。</li></ul><h5 id="Location配置："><a href="#Location配置：" class="headerlink" title="Location配置："></a>Location配置：</h5><ul><li><code>location / &#123; try_files $uri $uri/ =404; &#125;</code>：这个指令尝试找到请求的文件，如果找不到就返回404错误页面。<code>$&#123;uri&#125;</code>代表请求的URI，例如<code>/index.html</code>。<code>$uri/</code>代表目录，如果都找不到返回404。</li></ul><h5 id="日志配置："><a href="#日志配置：" class="headerlink" title="日志配置："></a>日志配置：</h5><ul><li><code>access_log /www/wwwlogs/yourblog_access.log;</code>：指定访问日志存放的位置。</li><li><code>error_log /www/wwwlogs/yourblog_error.log;</code>：指定错误日志存放的位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>打开 SSH 配置文件：<br>在终端中输入以下命令打开文件：<br>sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</li></ul><p>查找配置项：<br>在 vim 中，按 Esc 键进入命令模式，然后输入 &#x2F;PubkeyAuthentication 并按 Enter 键查找 PubkeyAuthentication 配置项。<br>确保该行未被注释（行首没有 #），并且设置为 yes：<br>PubkeyAuthentication yes</p><p>同样的方法查找 AuthorizedKeysFile 配置项，确保其设置为：<br>AuthorizedKeysFile .ssh&#x2F;authorized_keys</p><p>保存并退出：<br>按 Esc 键进入命令模式，然后输入 :wq 并按 Enter 键保存并退出 vim。<br>重启 SSH 服务：<br>修改配置文件后，需要重启 SSH 服务以使更改生效：<br>sudo systemctl restart sshd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">之后就成功了注意隐藏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`# cat /etc/passwd` 检查现在linx中所有用户</span><br><span class="line">`sudo passwd boke` 给boke设置密码</span><br><span class="line">`su - boke` 切换用户</span><br><span class="line">`sudo yum install git` 使用使用root用户或sudo命令安装</span><br><span class="line">`ps -ef | grep nginx`通过查看进程列表来确认 Nginx 是否在运行</span><br><span class="line">`sudo visudo` 系统级别的配置文件,可以用来添加权限</span><br><span class="line">`sudo chown -R boke:boke /var/www/blog`  这个命令用于改变 `/var/www/blog` 和其所有子目录及其内容的所有者（owner）和组所有者（group）。`-R` 参数表示递归（recursive），所以这个操作会应用于整个目录树。`boke:boke` 是指将所有文件和子目录的所有权更改为 `boke` 用户和 `boke` 组</span><br><span class="line">如何挂你nginx</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动 Nginx：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</p><p>重启 Nginx：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx restart</p><p>重新加载 Nginx 配置：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx reload</p><p>停止 Nginx：<br>sudo &#x2F;etc&#x2F;init.d&#x2F;nginx stop</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实战项目2</title>
      <link href="/2024/07/05/SpringBoot%E5%AE%9E%E6%88%98/"/>
      <url>/2024/07/05/SpringBoot%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Fastjson和ResponseBody区别"><a href="#Fastjson和ResponseBody区别" class="headerlink" title="Fastjson和ResponseBody区别"></a>Fastjson和ResponseBody区别</h1><p>现在的理解为fastjson和ResponseBody都是在springBoot实战里面将后端数据转换为json数据，他们的具体区别为ResponseBody为springmvc提供的<br>而fastjson是基于java库转换为json数据的。<br>一下是详细解释</p><ol><li><p><strong>Spring MVC 的 @ResponseBody</strong>：</p><ul><li>当你在 Spring MVC 控制器方法上使用 <code>@ResponseBody</code> 时，Spring 自动处理了将方法的返回值转换为 HTTP 响应体的过程。</li><li>它并不直接涉及具体的 JSON 序列化库，但通常会配合像 Jackson、Gson 或 Fastjson 这样的库来完成对象到 JSON 的转换。</li><li><code>@ResponseBody</code> 是一种约定，它告诉 Spring 不要尝试渲染视图，而是直接返回响应体。</li></ul></li><li><p><strong>Fastjson</strong>：</p><ul><li>Fastjson 是一个独立的 JSON 序列化&#x2F;反序列化库，用于将 Java 对象转换为 JSON 字符串或从 JSON 字符串反序列化为 Java 对象。</li><li>在没有 <code>@ResponseBody</code> 的情况下，你可以单独使用 Fastjson 来序列化 Java 对象，或者在 Spring MVC 中手动配置序列化器。</li></ul></li></ol><h2 id="字符编码的问题"><a href="#字符编码的问题" class="headerlink" title="字符编码的问题"></a>字符编码的问题</h2><p>  在实战中编码格式不对，中文导致浏览器无法识别，乱码 直接上</p><p> <strong>结论</strong><br>直接返回请求让浏览器识别utf-8格式，<code>response.setContentType(&quot;application/json;charset=UTF-8&quot;)</code></p><p>并且让响应数据格式也为utf-8<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code></p><p><strong>区别</strong></p><p>响应头编码 (Content-Type)：</p><p>作用：Content-Type 响应头告诉浏览器或客户端服务器返回的数据类型和字符编码。<br>示例：application&#x2F;json;charset&#x3D;UTF-8 表示返回的数据是 JSON 格式，并且使用 UTF-8 编码。<br>重要性：确保浏览器知道如何正确解析和显示返回的数据。</p><p>字符编码 (Character Encoding)：</p><p>作用：response.setCharacterEncoding(“UTF-8”) 设置了服务器在生成响应时使用的字符编码。<br>重要性：确保服务器在写入响应数据时使用正确的编码，特别是对于包含非 ASCII 字符（如中文）的数据。</p><p>两者结合直接无敌 utf-8</p><h2 id="mybatis写sql语句两种方法"><a href="#mybatis写sql语句两种方法" class="headerlink" title="mybatis写sql语句两种方法"></a>mybatis写sql语句两种方法</h2><p><strong>第一种</strong> 直接写在Mapper接口里面的，这个直接在接口上加上<code>@Mapper</code>的并且直接在方法上写上@Select或者其他CRUD的<br>直接是在本类上写sql语句，</p><p><strong>第二种</strong> 在抽象类写具体的方法名，它的实现在resource里相同的三层架构，对应一个接口，一个xml文件在里面写具体的sql语句<br>使得我们更加专注与sql语句的编写</p><p>接下来是相同的具体的优缺点详细解释</p><ul><li><strong>第一种使用注解编写SQL语句</strong></li></ul><p>优点：</p><p>简洁明了：直接在接口方法上编写SQL语句，代码量少，结构清晰。<br>方便维护：对于简单的SQL语句，使用注解可以减少文件数量，方便维护。<br>快速开发：适合快速开发和原型设计，减少了配置文件的编写时间。</p><p>缺点：</p><p>复杂SQL不便：对于复杂的SQL语句，注解方式不够直观，难以维护和调试。<br>灵活性差：注解方式在处理动态SQL时不如XML灵活。<br>可读性差：当SQL语句较长时，嵌入在代码中会影响代码的可读性。</p><ul><li><strong>第二种使用XML文件编写SQL语句</strong></li></ul><p>优点：</p><p>灵活性高：XML文件支持动态SQL，使用<if>、<choose>等标签可以方便地构建复杂的SQL语句。<br>分离关注点：将SQL语句与Java代码分离，增强了代码的可读性和可维护性。<br>易于调试：SQL语句独立于Java代码，便于调试和优化。</p><p>缺点：</p><p>配置繁琐：需要额外的XML配置文件，增加了项目的复杂度。<br>维护成本高：对于简单的SQL语句，使用XML文件显得过于复杂，维护成本较高。<br>开发效率低：编写和维护XML文件需要更多的时间和精力，不如注解方式高效</p><h2 id="在这个新的实战里大量用到了security"><a href="#在这个新的实战里大量用到了security" class="headerlink" title="在这个新的实战里大量用到了security"></a>在这个新的实战里大量用到了<code>security</code></h2><p>它的目的进行加密对密码,并且有一个</p><p><code>UserDetails</code>用来封装用来封装用户登录时所需的身份信息。这个接口或类定义了认证过程中需要获取的一些核心用户属性，以便进行用户验证和授权。</p><p><code>   &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;</code></p><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>如上文所说，我承认自己有点错误，它不仅是单单一个类，他是一个框架接下来看看官方的解释</p><h5 id="Spring-Security-是-Spring-家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。"><a href="#Spring-Security-是-Spring-家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。" class="headerlink" title="Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。"></a>Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。</h5><p> 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p><p>​ 一般Web应用的需要进行认证和授权。</p><p>​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</p><p>​ 授权：经过认证后判断当前用户是否有权限进行某个操作<br>咋一看，是不是特别很厉害，一开始小瞧它了</p><h2 id="牛逼的事来了，登录界面的-记住我"><a href="#牛逼的事来了，登录界面的-记住我" class="headerlink" title="牛逼的事来了，登录界面的 记住我"></a>牛逼的事来了，登录界面的 记住我</h2><p>首先，导入spring data jdbc ,然后 </p><p><code>@Autowired     DataSource dataSource;</code></p><p>好像引入了其目的它在 Spring Security 中用于“记住我”功能的持久化存储<br>&#96; @Bean</p><pre><code>public PersistentTokenRepository tokenRepository()&#123;    JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl();    jdbcTokenRepository.setDataSource(dataSource);    jdbcTokenRepository.setCreateTableOnStartup(true);    return jdbcTokenRepository;&#125;`</code></pre><p>  ** 注意上面的代码这段代码是用来配置一个 <code>PersistentTokenRepository</code> 实例的，它在 Spring Security 中用于“记住我”功能的持久化存储。具体来说：</p><ol><li><strong>创建 <code>JdbcTokenRepositoryImpl</code> 实例</strong>：<code>JdbcTokenRepositoryImpl</code> 是 <code>PersistentTokenRepository</code> 的一个实现类，用于将令牌存储在数据库中。</li><li><strong>设置数据源</strong>：通过 <code>jdbcTokenRepository.setDataSource(dataSource);</code> 将数据源注入到 <code>JdbcTokenRepositoryImpl</code> 中，这样它就可以访问数据库。</li><li><strong>创建表</strong>：<code>jdbcTokenRepository.setCreateTableOnStartup(true);</code> 指定在应用启动时自动创建所需的数据库表。</li></ol><p>这样配置后，Spring Security 会在用户选择“记住我”功能时，将相关的令牌信息存储在数据库中，而不是仅仅保存在内存中¹²。</p><p>这段代码配置了 Spring Security 的“记住我”功能，具体功能如下：</p><ol><li>**<code>.rememberMe()</code>**：启用“记住我”功能。</li><li>**<code>.rememberMeParameter(&quot;remember&quot;)</code>**：指定表单中用于“记住我”功能的参数名称为 <code>remember</code>。</li><li>**<code>.tokenRepository(this.tokenRepository())</code>**：设置令牌存储库为之前配置的 <code>JdbcTokenRepositoryImpl</code>，用于将令牌存储在数据库中。</li><li>**<code>.tokenValiditySeconds(3600*24)</code>**：设置令牌的有效期为 24 小时（3600 秒 * 24）。</li></ol><p>结合之前的 <code>tokenRepository</code> 方法，这段代码的作用是：</p><ul><li>当用户在登录时选择“记住我”选项时，Spring Security 会生成一个持久化的令牌，并将其存储在数据库中。</li><li>该令牌会被发送到用户的浏览器，并存储在 cookie 中。</li><li>在用户关闭浏览器并重新打开时，Spring Security 会根据该令牌自动验证用户身份，免去重新登录的步骤¹².</li></ul><p>这样配置后，用户在选择“记住我”功能后，即使关闭浏览器，也能在 24 小时内自动登录。</p><h3 id="它创建了一个表"><a href="#它创建了一个表" class="headerlink" title="它创建了一个表"></a>它创建了一个表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JdbcTokenRepositoryImpl 使用提供的数据源将令牌插入数据库。</span><br><span class="line">插入使用的 SQL 查询通常如下：</span><br><span class="line">SQL</span><br><span class="line"></span><br><span class="line">INSERT INTO persistent_logins (username, series, token, last_used) VALUES (?, ?, ?, ?)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="利用spring框架-mail-和自己的邮箱实现注册邮箱的功能"><a href="#利用spring框架-mail-和自己的邮箱实现注册邮箱的功能" class="headerlink" title="利用spring框架 mail 和自己的邮箱实现注册邮箱的功能"></a>利用spring框架 mail 和自己的邮箱实现注册邮箱的功能</h2><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>上面导入所需要的框架</p><pre><code>   @AutowiredMailSender mailSender;</code></pre><p>自动导入MailSender<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> datasource:</span><br><span class="line">   driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">   url: jdbc:mysql://localhost:3306/study-project?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">   username: root</span><br><span class="line">   password: 123456789</span><br><span class="line"> mail:</span><br><span class="line">   default-encoding: utf-8</span><br><span class="line">   host: smtp.139.com</span><br><span class="line">   username: 邮箱地址</span><br><span class="line">   password: 0b63a830468ccd 授权码</span><br><span class="line">   protocol: smtp</span><br><span class="line">   port: 465</span><br><span class="line">   properties:</span><br><span class="line">         from: 邮箱地址</span><br><span class="line">         mail:</span><br><span class="line">           smtp:</span><br><span class="line">             auth: true</span><br><span class="line">             starttls:</span><br><span class="line">               enable: true</span><br><span class="line">             ssl:</span><br><span class="line">               enable: true</span><br></pre></td></tr></table></figure><br>上面把相应的配置配一下，记住ssl，和非ssl， port端口不一样，记得改一下，现在开启了 ssl，不开启端口改为25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendVaildateEmail(String email)&#123;</span><br><span class="line">            int a= (int) (Math.random()*900000)+100000;</span><br><span class="line">        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();</span><br><span class="line">        simpleMailMessage.setFrom(b);</span><br><span class="line">        simpleMailMessage.setTo(email);</span><br><span class="line">        simpleMailMessage.setSubject(&quot;Spring实战2验证邮件&quot;);</span><br><span class="line">        simpleMailMessage.setText(&quot;验证码是：&quot;+a);</span><br><span class="line">        try&#123;</span><br><span class="line">            mailSender.send(simpleMailMessage);</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;catch (MailException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意setfrom是发件的是谁<br>setto是发给了谁<br>setsubject,是发件的主题是啥<br>settext,是发件的内容是啥。</p><p>上面首先创建SimpleMailMessage实例，将相应的内容填进去 ，然后mailSender.send(simpleMailMessage)直接发送</p><h2 id="登录权限验证"><a href="#登录权限验证" class="headerlink" title="登录权限验证"></a>登录权限验证</h2><p>Spring Context 本身并不直接存储登录信息，但它可以管理和配置与登录相关的组件。例如，Spring Security 是一个用于保护 Spring 应用程序的框架，它可以与 Spring Context 集成来处理身份验证和授权。</p><p>在这种情况下，Spring Context 会管理与登录相关的 Bean，例如用户详情服务（UserDetailsService）、身份验证管理器（AuthenticationManager）等。这些组件会处理用户登录信息的验证和存储，但实际的登录信息（如用户名和密码）通常存储在数据库或其他持久化存储中。</p><h1 id="Spring-Security-1"><a href="#Spring-Security-1" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>Spring Security 默认会拦截未登录的用户</p><h2 id="Spring-Security-使用过滤器链来处理所有进入的-HTTP-请求，"><a href="#Spring-Security-使用过滤器链来处理所有进入的-HTTP-请求，" class="headerlink" title="Spring Security 使用过滤器链来处理所有进入的 HTTP 请求，"></a>Spring Security 使用过滤器链来处理所有进入的 HTTP 请求，</h2><p>下面是某网站系统的Security,我将详细给你分析讲一下，各个究竟是干啥的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line"> public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">     return http</span><br><span class="line">             .authorizeHttpRequests()</span><br><span class="line">             .requestMatchers(&quot;/api/auth/**&quot;)</span><br><span class="line">             .permitAll()</span><br><span class="line">             .anyRequest()</span><br><span class="line">             .authenticated()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .formLogin()</span><br><span class="line">             .loginProcessingUrl(&quot;/api/auth/login&quot;)</span><br><span class="line">             .successHandler(this::onAuthenticationSuccess</span><br><span class="line"></span><br><span class="line">             )</span><br><span class="line">             .failureHandler(this::onAuthenticationFailure</span><br><span class="line"></span><br><span class="line">             )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .logout()</span><br><span class="line">             .logoutUrl(&quot;/api/auth/logout&quot;)</span><br><span class="line">             .logoutSuccessHandler(this::onAuthenticationSuccess)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .rememberMe()</span><br><span class="line">             .rememberMeParameter(&quot;remember&quot;)</span><br><span class="line">             .tokenRepository(this.tokenRepository())</span><br><span class="line">             .tokenValiditySeconds(3600*24)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .csrf()</span><br><span class="line">             .disable()</span><br><span class="line">             .cors()</span><br><span class="line">             .configurationSource(this.corsConfigurationSource())</span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .exceptionHandling()</span><br><span class="line">             .authenticationEntryPoint(this::onAuthenticationFailure)</span><br><span class="line"></span><br><span class="line">             .and()</span><br><span class="line">             .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    return http</span><br><span class="line">        .authorizeHttpRequests()</span><br><span class="line">        .requestMatchers(&quot;/api/auth/**&quot;)</span><br><span class="line">        .permitAll()</span><br><span class="line">        .anyRequest()</span><br><span class="line">        .authenticated()</span><br></pre></td></tr></table></figure><p>上面的authorizeHttpRequests() 开始配置请求授权</p><p>requestMatchers(“&#x2F;api&#x2F;auth&#x2F;“).permitAll()<strong>：允许 &#x2F;api&#x2F;auth&#x2F;</strong> 路径下的所有请求匿名访问，不需要认证</p><p>.anyRequest()<br>.authenticated()  其他所有请求都需要认证。</p><pre><code>   .and()    .formLogin()    .loginProcessingUrl(&quot;/api/auth/login&quot;)    .successHandler(this::onAuthenticationSuccess)    .failureHandler(this::onAuthenticationFailure)</code></pre><p>formLogin()：启用表单登录。</p><p>loginProcessingUrl(“&#x2F;api&#x2F;auth&#x2F;login”)：指定处理登录请求的 URL。</p><p>successHandler(this::onAuthenticationSuccess)：登录成功后的处理逻辑。</p><p>failureHandler(this::onAuthenticationFailure)：登录失败后的处理逻辑。</p><pre><code>    .and()    .logout()    .logoutUrl(&quot;/api/auth/logout&quot;)    .logoutSuccessHandler(this::onAuthenticationSuccess)</code></pre><p>logout()：启用注销功能</p><p>logoutUrl(“&#x2F;api&#x2F;auth&#x2F;logout”)：指定处理注销请求的 URL。</p><pre><code>    .and()    .rememberMe()    .rememberMeParameter(&quot;remember&quot;)    .tokenRepository(this.tokenRepository())    .tokenValiditySeconds(3600 * 24)</code></pre><p>rememberMe()：启用“记住我”功能。</p><p>rememberMeParameter(“remember”)：指定“记住我”参数的名称。</p><p>tokenRepository(this.tokenRepository())：指定用于存储“记住我”令牌的存储库。</p><p>tokenValiditySeconds(3600 * 24)：设置“记住我”令牌的有效期（秒）。</p><pre><code>    .and()    .csrf().disable()    .cors().configurationSource(this.corsConfigurationSource())</code></pre><p>csrf().disable()：禁用 CSRF 保护。</p><p>cors().configurationSource(this.corsConfigurationSource())：启用 CORS，并指定 CORS 配置源。</p><pre><code>    .and()    .exceptionHandling()    .authenticationEntryPoint(this::onAuthenticationFailure)</code></pre><p>exceptionHandling()：配置异常处理。</p><p>authenticationEntryPoint(this::onAuthenticationFailure)：指定未认证用户访问受保护资源时的处理逻辑。</p><pre><code>    .and()    .build();</code></pre><p>}</p><p>build()：构建并返回 SecurityFilterChain 对象。</p><h3 id="跨域资源CORS"><a href="#跨域资源CORS" class="headerlink" title="跨域资源CORS"></a>跨域资源CORS</h3><p>上方指定cors配置源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private CorsConfigurationSource corsConfigurationSource() &#123;</span><br><span class="line">    CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">    corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);</span><br><span class="line">    corsConfiguration.setAllowCredentials(true);</span><br><span class="line">    corsConfiguration.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">    corsConfiguration.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">    corsConfiguration.addExposedHeader(&quot;*&quot;);</span><br><span class="line">    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">    source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>CORS 配置：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CorsConfiguration corsConfiguration = new CorsConfiguration();：创建一个新的 CorsConfiguration 对象，用于存储 CORS 配置。</span><br><span class="line">允许所有来源：</span><br><span class="line">corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);：允许所有来源的请求。* 表示任何来源都可以访问。</span><br><span class="line">允许携带凭证：</span><br><span class="line">corsConfiguration.setAllowCredentials(true);：允许请求携带凭证（如 cookies）。</span><br><span class="line">允许所有请求头：</span><br><span class="line">corsConfiguration.addAllowedHeader(&quot;*&quot;);：允许所有请求头。</span><br><span class="line">允许所有 HTTP 方法：</span><br><span class="line">corsConfiguration.addAllowedMethod(&quot;*&quot;);：允许所有 HTTP 方法（如 GET、POST、PUT、DELETE 等）。</span><br><span class="line">暴露所有响应头：</span><br><span class="line">corsConfiguration.addExposedHeader(&quot;*&quot;);：允许客户端访问所有响应头。</span><br><span class="line">注册 CORS 配置：</span><br><span class="line">UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();：创建一个 UrlBasedCorsConfigurationSource 对象，用于注册 CORS 配置。</span><br><span class="line">source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);：将 CORS 配置应用于所有路径（/**）。</span><br><span class="line">返回 CORS 配置源：</span><br><span class="line">return source;：返回配置好的 CorsConfigurationSource 对象。</span><br></pre></td></tr></table></figure><h3 id="究竟谁开启的跨域的请求"><a href="#究竟谁开启的跨域的请求" class="headerlink" title="究竟谁开启的跨域的请求"></a>究竟谁开启的跨域的请求</h3><p>答案，他们共同作用导致不用在Controller加上@CrossOrigin这个注解了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.setAllowCredentials(true);</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>他们真是让我醉了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">corsConfiguration.addAllowedOriginPattern(&quot;*&quot;);：允许所有来源的请求。</span><br><span class="line">corsConfiguration.setAllowCredentials(true);：允许发送凭证（如 cookies）。</span><br><span class="line">corsConfiguration.addAllowedHeader(&quot;*&quot;);：允许所有请求头。</span><br><span class="line">corsConfiguration.addAllowedMethod(&quot;*&quot;);：允许所有 HTTP 方法（如 GET、POST、PUT、DELETE 等）。</span><br><span class="line">corsConfiguration.addExposedHeader(&quot;*&quot;);：允许客户端访问所有响应头</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使得跨域请求在全局范围内被允许，而不需要在每个 Controller 上单独配置 @CrossOrigin</p><h3 id="在拦截器中返回用户信息"><a href="#在拦截器中返回用户信息" class="headerlink" title="在拦截器中返回用户信息"></a>在拦截器中返回用户信息</h3><p>在mvcConfiguration里,配置拦截器，拦截所有，并放开，注册页面请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> @Resource</span><br><span class="line">    AuthorizeInterceptor authorizeInterceptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(authorizeInterceptor)</span><br><span class="line">                .addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/api/auth/**&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将请求后的个人信息数据,存到Session里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AuthorizeInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        SecurityContext context= SecurityContextHolder.getContext();</span><br><span class="line">        Authentication authentication=context.getAuthentication();</span><br><span class="line">         User user = (User) authentication.getPrincipal();</span><br><span class="line">        String username = user.getUsername();</span><br><span class="line">        Account account = userMapper.finduser(username);</span><br><span class="line">        request.getSession().setAttribute(&quot;account&quot;,account);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在这讲一讲,注册拦截问题</strong></p><p>拦截器的 preHandle 方法会尝试从当前的安全上下文中获取用户信息，并将用户的账户信息存储到会话中。然而，在用户登录请求时，用户还没有经过身份验证，<br>所以安全上下文中没有用户信息。这会导致 preHandle 方法无法正确处理登录请求，可能会抛出异常或导致其他问题。</p><p>通过排除 &#x2F;api&#x2F;auth&#x2F;** 路径，你可以确保登录请求不会经过拦截器的处理逻辑，从而避免这些问题。登录请求可以正常进行，用户身份验证成功后，其他请求才会经过拦截器进行预处理。</p><h2 id="Spring-Security-登录思路"><a href="#Spring-Security-登录思路" class="headerlink" title="Spring Security 登录思路"></a>Spring Security 登录思路</h2><p>注意它不走Controller层，在拦截器层，直接拦下，在拦截器那一层，首先会在拦截器这一层会有实现UserDetailsService的Service层的注入,<br>调用Service层的里面的UserDetail方法，在这一层将用usermapper层，进行用户名查找，所有数据  注意只有一个参数，SpringSecurity会自动识别用户名<br>，用用户名查找所有数据，之后在Configuration进行第二步，整合BCcript到AuthenticationManager authenticationManager这一方法<br>自动将密码和数据库查到的想对比，成功调用.successHandler （this::onAuthenticationSuccess），失败调用.failureHandler(this::onAuthenticationFailure）</p><pre><code>       、</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Connfiguration</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(&quot;/api/auth/login&quot;)</span><br><span class="line">                .successHandler(this::onAuthenticationSuccess</span><br><span class="line"></span><br><span class="line">                )</span><br><span class="line">                .failureHandler(this::onAuthenticationFailure</span><br><span class="line"></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl(&quot;/api/auth/logout&quot;)</span><br><span class="line">                .logoutSuccessHandler(this::onAuthenticationSuccess)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationManager authenticationManager(HttpSecurity httpSecurity)throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        return httpSecurity</span><br><span class="line">                .getSharedObject(AuthenticationManagerBuilder.class)</span><br><span class="line">                .userDetailsService(a)</span><br><span class="line">                .passwordEncoder(passwordEncoder())</span><br><span class="line">                .and()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       @Bean</span><br><span class="line">    public BCryptPasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UserService</span><br><span class="line">                        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">                            if (username==null)</span><br><span class="line">                                throw new UsernameNotFoundException(&quot;用户名为空&quot;);</span><br><span class="line">                            User user = userMapper.FindAllByUsernameOrEmail(username);</span><br><span class="line">                            if(user==null)</span><br><span class="line">                                throw new UsernameNotFoundException(&quot;用户名不存在&quot;);</span><br><span class="line"></span><br><span class="line">                            return org.springframework.security.core.userdetails.User</span><br><span class="line">                                    .withUsername(user.getUsername())</span><br><span class="line">                                    .password(user.getPassword())</span><br><span class="line">                                    .roles(&quot;user&quot;)</span><br><span class="line">                                    .build();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="redis进行验证码校验"><a href="#redis进行验证码校验" class="headerlink" title="redis进行验证码校验"></a>redis进行验证码校验</h2><p>pom 导入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在UserService注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">StringRedisTemplate template;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**注意主要业务逻辑处理都在Service层，Controller，只要结果，它根据结果进行返回操作，所以在这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public String sendVaildateEmail(String email, String Sessionid,boolean hashAccound)&#123;</span><br><span class="line">                           int a= (int) (Math.random()*900000)+100000;</span><br><span class="line">                       String key=&quot;email:&quot;+email+&quot;sessionid:&quot;+Sessionid+hashAccound;</span><br><span class="line">                       if(Boolean.TRUE.equals(template.hasKey(key)))&#123;</span><br><span class="line">                           Long aLong = Optional.ofNullable(template.getExpire(key, TimeUnit.SECONDS)).orElse(0l);</span><br><span class="line">                           if(aLong&gt;120) return &quot;请求频繁，稍后再试&quot;;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (hashAccound&amp;&amp;userMapper.FindAllByUsernameOrEmail(email)==null)&#123;</span><br><span class="line">                           return &quot;没有此邮件地址的账户&quot;;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                       if(!hashAccound&amp;&amp;userMapper.FindAllByUsernameOrEmail(email)!=null)&#123;</span><br><span class="line"></span><br><span class="line">                           return &quot;邮箱已被其他用户注册&quot;;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       SimpleMailMessage simpleMailMessage = new SimpleMailMessage();</span><br><span class="line">                       simpleMailMessage.setFrom(b);</span><br><span class="line">                       simpleMailMessage.setTo(email);</span><br><span class="line">                       simpleMailMessage.setSubject(&quot;Spring实战2验证邮件&quot;);</span><br><span class="line">                       simpleMailMessage.setText(&quot;验证码是：&quot;+a);</span><br><span class="line">                       try&#123;</span><br><span class="line">                           mailSender.send(simpleMailMessage);</span><br><span class="line"></span><br><span class="line">                           template.opsForValue().set(key,String.valueOf(a),3, TimeUnit.MINUTES);</span><br><span class="line">                           return null;</span><br><span class="line"></span><br><span class="line">                       &#125;catch (MailException e)&#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           return &quot;请联系管理员，检查邮箱&quot;;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>从上面里面抽出redis的用法为</p><p>template.opsForValue().set(key,String.valueOf(a),3, TimeUnit.MINUTES);<br>设置key，和有效期，<br><code>template.getExpire(key, TimeUnit.SECONDS)</code>从里面得到验证码，的时间</p><p>template.hasKey(key))是否相等。<br>上面的邮箱发送请看上面的章节，这里不在讲。</p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习SpringBoot3+ssm+spring6三月后疑难点总结</title>
      <link href="/2024/07/04/SpringBoot3+ssm+spring6/"/>
      <url>/2024/07/04/SpringBoot3+ssm+spring6/</url>
      
        <content type="html"><![CDATA[<h1 id="拖延太拖延了"><a href="#拖延太拖延了" class="headerlink" title="拖延太拖延了"></a>拖延太拖延了</h1><p>本来就没有多少时间还拖沓，也是很服自己的</p><h1 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h1><h2 id="Autowored和Resource"><a href="#Autowored和Resource" class="headerlink" title="Autowored和Resource"></a>Autowored和Resource</h2><p>Autowored</p><p>是由Spring提供的一个注解，用于自动装配，注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。<br>Qualifier<br>bean定义或者AOP切面的引用。这个注解用于指定在依赖注入时，应该使用哪个特定的bean实例，即使它们具有相同的类型。当你有多个同类型的bean存在，并且希望明确指定其中一个时，可以使用<code>@Qualifier</code>来区分</p><p>Resource</p><p>注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在@Bean标识之后，加上@Scope可以实现单例和多例模式，<br>@Scope(“prototype”)&#96; 是Spring框架中的一个作用域注解，它用于定义Spring管理的bean的生命周期。在Spring中，bean可以分为几种不同的作用域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Singleton (默认): 单例模式，意味着在整个应用上下文中只有一个实例。这是最常见的作用域，适用于那些不需要修改状态或者需要共享数据的bean。</span><br><span class="line"></span><br><span class="line">2. Prototype: 原型模式，每个请求都会创建一个新的bean实例。这意味着每次通过@Autowired注入到需要这个bean的地方，都会得到一个新的对象，适合用于创建临时的对象或者不可变的对象。</span><br><span class="line"></span><br><span class="line">当你在bean上使用`@Scope(&quot;prototype&quot;)`时，Spring会在每次bean被请求时都创建一个新的实例，而不是在整个应用程序运行期间只创建一次。这对于那些需要根据请求或用户行为动态创建对象的场景非常有用，比如缓存策略或者生成报告时。</span><br></pre></td></tr></table></figure><h2 id="多个配置类-Import导入"><a href="#多个配置类-Import导入" class="headerlink" title="多个配置类@Import导入"></a>多个配置类@Import导入</h2><p>@Import 注释允许从另一个配置类加载 @Bean 定义，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public A a() &#123;</span><br><span class="line">    return new A();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public B b() &#123;</span><br><span class="line">    return new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的操作A导入B配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line"></span><br><span class="line">    // now both beans A and B will be available...</span><br><span class="line">    A a = ctx.getBean(A.class);</span><br><span class="line">    B b = ctx.getBean(B.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面实例化B但是用了A的里面的Bean，就是这个意思</p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用idea写前端vue spring实战2</title>
      <link href="/2024/07/04/%E7%94%A8idea%E5%86%99%E5%89%8D%E7%AB%AFvue/"/>
      <url>/2024/07/04/%E7%94%A8idea%E5%86%99%E5%89%8D%E7%AB%AFvue/</url>
      
        <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>首先必须安装node.js，这个之前已经安装过了，之后用了spring的生成器，用来快速构建spring，<br>之后在控制端用了npm install -g create-vue这个是成功了但是用create-vue的时候失败了<br>之后用npm init vue@latest成功，就是这个<br>最后在构建模块把前端的模块变成和后端一样。</p><h3 id="两个构建方式有什么不同"><a href="#两个构建方式有什么不同" class="headerlink" title="两个构建方式有什么不同"></a>两个构建方式有什么不同</h3><p>create-vue</p><p>全局安装：需要先通过 npm install -g create-vue 全局安装。<br>命令简洁：安装后可以直接使用 create-vue 命令创建项目。<br>基于 Vite：创建的项目默认使用 Vite 作为构建工具。</p><p>npm init vue@latest</p><p>无需全局安装：直接使用 npm init vue@latest 命令，无需预先安装其他工具。<br>交互式配置：命令执行后，会进入一个交互式的配置界面，允许你选择项目的各种配置选项2。<br>基于 Vite：同样使用 Vite 作为构建工具。</p><h3 id="什么是vite"><a href="#什么是vite" class="headerlink" title="什么是vite"></a>什么是vite</h3><p>Vite（法语意为 “快速的”，发音 &#x2F;vit&#x2F;，发音同 “veet”）是一种新型前端构建工具，旨在显著提升前端开发体验12。</p><figure class="highlight plaintext"><figcaption><span>“快速的”，发音</span><a href="/vit/，发音同">“veet”）是一种新型前端构建工具，旨在显著提升前端开发体验12。</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">主要特点</span><br><span class="line">极速的服务启动：使用原生 ES 模块文件，无需打包，启动速度极快2。</span><br><span class="line">模块热更新（HMR）：提供快速的模块热替换，无论应用程序大小如何，都能保持极快的热重载2。</span><br><span class="line">丰富的功能：对 TypeScript、JSX、CSS 等支持开箱即用2。</span><br><span class="line">优化的构建：使用 Rollup 打包代码，输出高度优化的静态资源1。</span><br><span class="line">插件 API：提供灵活的插件 API 和 JavaScript API，带来高度的可扩展性1。</span><br></pre></td></tr></table></figure><h2 id="vue3前置工作"><a href="#vue3前置工作" class="headerlink" title="vue3前置工作"></a>vue3前置工作</h2><p>安装完之后用已经得到了基本的vue3基本框架，接下来把它的初始页面删了，留下空白面板，接下来用到vue3的框架<code>element-plus</code>框架快速构建vue3<br>然后再安装vue-axios两者的具体命令为 <code>npm install element-plus --save</code>和<code>npm install vue-axios --save</code></p><p>下面是两者的具体介绍</p><p>Element Plus：<br>Element Plus 是一个基于 Vue 3 的高质量 UI 组件库12。它提供了丰富的组件，如表格、表单、按钮、导航、通知等，帮助开发者快速构建高质量的 Web 应用3。</p><p>vue-axios：<br>vue-axios 是一个将 axios 集成到 Vue.js 中的小型封装库。axios 是一个基于 promise 的 HTTP 客户端，用于向 API 发送请求并处理响应数据6。</p><h3 id="ElementPlusResolver按需自动导入配置插件"><a href="#ElementPlusResolver按需自动导入配置插件" class="headerlink" title="ElementPlusResolver按需自动导入配置插件"></a>ElementPlusResolver按需自动导入配置插件</h3><p>首先全局安装了插件<code>npm install -D unplugin-vue-components unplugin-auto-import</code>之两个插件详情在<code>https://element-plus.org/zh-CN/guide/quickstart.html</code><br>我这里出现错误记得把前面的导入也导一下,</p><h2 id="jsp与vue3的区别"><a href="#jsp与vue3的区别" class="headerlink" title="jsp与vue3的区别"></a>jsp与vue3的区别</h2><p>我写页面用jsp习惯了，但是好像jsp页面被淘汰了，现在vue页面已经是主流了<br>下面是两者的详细解释</p><p>目前，Vue 在前端开发中比 JSP 更受欢迎，尤其是在构建现代化的单页面应用（SPA）时¹²。Vue 提供了更好的用户体验和开发效率，支持组件化开发和前后端分离，这使得它在前端开发者中广受欢迎¹²。</p><p>JSP 主要用于传统的 Java Web 开发，虽然在一些老旧项目中仍然使用，但新项目中使用 JSP 的情况已经大大减少¹²。</p><p>原来我已经落伍了，</p><h2 id="如上文所说我又安装-axios"><a href="#如上文所说我又安装-axios" class="headerlink" title="如上文所说我又安装 axios"></a>如上文所说我又安装 axios</h2><p><code>npm install axios</code></p><p>这个插件主要是为了，浏览器无缝链接后端，处理http请求，无缝链接的框架又，vue，rest等，具体介绍，所示</p><ul><li>Axios 是一个基于 Promise 的 JavaScript HTTP 库，主要用于浏览器和 Node.js 环境中的客户端应用。它的主要作用是提供一个简单、统一的方式来发送 HTTP 请求，并处理响应。Axios 支持浏览器和 Node.js 中的同步和异步请求，可以与各种现有的框架（如 Vue.js、React、Angular 等）无缝集成。</li></ul><blockquote><p>以下是 Axios 的一些关键特性：</p><ol><li><p><strong>Promise-based</strong>: Axios 返回的是一个 Promise 对象，可以使用 <code>.then()</code> 和 <code>.catch()</code> 来处理成功和错误响应。</p></li><li><p><strong>跨域支持</strong>: 它内置了对 CORS（跨源资源共享）的支持，可以在发送请求时自动添加必要的头信息。</p></li><li><p><strong>转换请求和响应数据</strong>: Axios 可以自动转换 JSON 数据，支持配置请求和响应的数据格式（如 JSON、XML、Form Data 等）。</p></li><li><p><strong>拦截器</strong>: Axios 提供了全局请求和响应拦截器，允许你在发送请求前或响应返回后执行自定义逻辑。</p></li><li><p><strong>取消请求</strong>: 可以通过 <code>cancel</code> 方法取消正在执行的请求。</p></li><li><p><strong>并发请求管理</strong>: 支持批量请求和取消批量请求，可以控制并发请求的数量。</p></li></ol></blockquote><p><strong>Axios</strong> 是一个基于 Promise 的 HTTP 客户端库，可以在浏览器和 Node.js 中使用。它独立于任何框架，可以在各种前端项目中使用¹²。</p><p><strong>vue-axios</strong> 是一个将 Axios 集成到 Vue.js 的包装器。它允许你像插件一样安装和使用 Axios，从而简化了在 Vue 组件中使用 Axios 的过程³⁴。具体来说，vue-axios 使得你不需要在每个组件中单独导入 Axios，而是可以通过 <code>this.$http</code> 或 <code>this.axios</code> 直接访问³。</p><p>总结一下：</p><ul><li><strong>Axios</strong>：独立库，适用于各种前端项目。</li><li><strong>vue-axios</strong>：Vue.js 插件，简化了在 Vue 项目中使用 Axios 的过程。</li></ul><h2 id="Element-Plus框架自带表单检验功能"><a href="#Element-Plus框架自带表单检验功能" class="headerlink" title="Element Plus框架自带表单检验功能"></a>Element Plus框架自带表单检验功能</h2><p>把表单里的内容框放在&lt;el -from&gt;表单里，<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">         &lt;el-form-item prop=&quot;username&quot;&gt;</span><br><span class="line">             &lt;el-input v-model=&quot;form.username&quot; style=&quot;width: 400px;margin-left: 45px ;margin-top: 15px&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;  &gt;</span><br><span class="line">             &lt;template #prefix&gt;</span><br><span class="line">         &lt;el-icon&gt;&lt;User/&gt;&lt;/el-icon&gt;</span><br><span class="line">           &lt;/template&gt;</span><br><span class="line">           &lt;/el-input&gt;</span><br><span class="line">     &lt;/el-form-item&gt;&#125;  </span><br></pre></td></tr></table></figure><br>下面是具体的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const validateUsername= (rule, value, callback) =&gt; &#123;</span><br><span class="line">  if (value === &#x27;&#x27;) &#123;</span><br><span class="line">    callback(new Error(&#x27;请输入用户名&#x27;))</span><br><span class="line">  &#125; else if(!/^(?:(?=[\u4e00-\u9fa5])[\u4e00-\u9fa5]*|(?=[a-zA-Z])[a-zA-Z]*)$/.test(value))&#123;</span><br><span class="line">    callback(new Error(&quot;用户名只能为中文或者英文&quot;))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码定义了validateUsername的函数创建判断规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const rules=</span><br><span class="line">      &#123;</span><br><span class="line">        username: [</span><br><span class="line">          &#123; validator:validateUsername, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125;,</span><br><span class="line">          &#123; min: 3, max: 15, message: &#x27;长度为3-15&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面的代码引用了username就是<strong>prop</strong>，另外还有rules规则。<br>注意其中的validator指定了一个函数这个函数会在特定的事件（如输入框失去焦点或内容改变）触发时执行，</p><h2 id="验证邮箱是否合法-是否展示获取验证码按钮出现"><a href="#验证邮箱是否合法-是否展示获取验证码按钮出现" class="headerlink" title="验证邮箱是否合法-是否展示获取验证码按钮出现"></a>验证邮箱是否合法-是否展示获取验证码按钮出现</h2><p><code> &lt;el-button type=&quot;primary&quot; style=&quot; margin-top: 10px&quot; :disabled=&quot;!isEmailValid&quot;&gt;获取验证码&lt;/el-button&gt;</code><br>上面的 :disabled</p><p>用于控制元素的禁用状态。它的值是一个布尔表达式，当表达式的值为 true 时，元素会被禁用；当值为 false 时，元素会被启用<br><code>&lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; @validate=&quot;onValidate&quot;&gt;</code><br>上面的@validate动态绑定了<strong>表单</strong>里面的所有的prop都要验证<br>并且声明了<code>const isEmailValid= ref (false)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const onValidate =(prop,isValid)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (prop===&#x27;email&#x27;)</span><br><span class="line">    isEmailValid.value=isValid</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说@validate&#x3D;”onValidate”每次验证都会调用一次，假设验证的是email，注意看如果email验证通过，那么isVaild为true<br>那么prop email,isVaild true,被带入，if语句会成功，isEmailValid会被设置为true。那么:disabled&#x3D;的语句是真就禁用，又加上 ！isEmailValid会被设置为false，为假。不禁用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    type: &#x27;email&#x27;,</span><br><span class="line">    message: &#x27;请输入合法的邮箱地址&#x27;,</span><br><span class="line">    trigger: [&#x27;blur&#x27;, &#x27;change&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123; required: true, message: &#x27;请输入邮箱地址&#x27;, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>规则里面的是blur，和changge。意思是他聚焦和改变了，就验证，required是否必须验证</p><h3 id="验证表单所有框全部正确，Element-Plus，表单提供了一个validate"><a href="#验证表单所有框全部正确，Element-Plus，表单提供了一个validate" class="headerlink" title="验证表单所有框全部正确，Element Plus，表单提供了一个validate"></a>验证表单所有框全部正确，Element Plus，表单提供了一个validate</h3><p>在表单上加上引用组件 <code>&lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; @validate=&quot;onValidate&quot; ref=&quot;formRef&quot;&gt;</code><br>ref&#x3D;   自定义<br>它的目的是访问和操作表单组件实例，进行验证<br>在script里面加上<br><code> const formRef=ref()</code></p><p>在立即注册的按钮上加上<code>&lt;el-button style=&quot;width: 270px ;margin-left: 80px&quot; type=&quot;warning&quot; @click=&quot;register()&quot;&gt;立即注册&lt;/el-button&gt;</code><br>click函数<br>注册调用 formRef.value.validate操作表单进行验证isValid是否为真</p><figure class="highlight plaintext"><figcaption><span>register </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    formRef.value.validate((isValid)=&gt;&#123;</span><br><span class="line">      if (isValid)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        ElMessage.warning(&quot;请填写完整表单&quot;)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    const validatePassword_repeat = (rule, value, callback) =&gt; &#123;</span><br><span class="line">      if (value === &#x27;&#x27;) &#123;</span><br><span class="line">        callback(new Error(&#x27;请再次确认密码&#x27;))</span><br><span class="line">      &#125; else if (value !== form.password) &#123;</span><br><span class="line">        callback(new Error(&quot;两次密码不同&quot;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const rules=&#123;</span><br><span class="line">        password_repeat:[</span><br><span class="line">        </span><br><span class="line">            &#123; validator:validatePassword_repeat, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125;,</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">          ],</span><br><span class="line">          &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面自定义自定义的验证函数，用于验证两次输入的密码是否一致。<br>上面的3个参数为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rule：验证规则对象，通常包含验证的相关信息。</span><br><span class="line">value：当前输入框的值，即用户输入的内容。</span><br><span class="line">callback：回调函数，用于返回验证结果。</span><br></pre></td></tr></table></figure><p>callback()</p><p>函数用于返回验证结果。它接受一个参数，如果传递的是 Error 对象，则表示验证失败；如果不传递参数或传递 null，则表示验证通过。</p><p>trigger 指定了验证触发的时机，这里是 blur（失去焦点）和 change（值改变）时触发验证。</p><h2 id="Element-UI-组件"><a href="#Element-UI-组件" class="headerlink" title="Element UI 组件"></a>Element UI 组件</h2><h3 id="步骤条"><a href="#步骤条" class="headerlink" title="步骤条"></a>步骤条</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-steps style=&quot;max-width: 600px&quot; :active=&quot;active&quot; finish-status=&quot;success&quot;&gt;</span><br><span class="line">    &lt;el-step title=&quot;Step 1&quot; /&gt;</span><br><span class="line">    &lt;el-step title=&quot;Step 2&quot; /&gt;</span><br><span class="line">    &lt;el-step title=&quot;Step 3&quot; /&gt;</span><br><span class="line">  &lt;/el-steps&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>加在<template> 里面 </template><br>最少的步骤条为2，也就是从0,1开始,需要定宽的步骤条时，设置 space 属性即可,里面有好多用法，具体你可以看Element的官网。<br>这里只讲，本实战用到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-steps style=&quot;max-width: 600px&quot; :active=&quot;active&quot; finish-status=&quot;success&quot;&gt;</span><br><span class="line">          &lt;el-step title=&quot;验证电子邮件&quot; /&gt;</span><br><span class="line">          &lt;el-step title=&quot;修改密码&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/el-steps&gt;</span><br></pre></td></tr></table></figure><p>可以在里面设置中文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;active===0&quot;&gt;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>通过 v-if可以展示或则隐藏，v-if指令可以用于隐藏元素。当active变量的值不等于0时，这个<div>元素及其内容将不会被渲染到页面上，相当于被隐藏了</p><pre><code>            // 开始或重置表单验证和提交过程的函数const startreset = () =&gt; &#123;            // 验证表单字段formRef.value.validate((isValid) =&gt; &#123;            // 如果表单有效if (isValid) &#123;           // 发送POST请求到指定的API端点，附带表单数据post(&quot;api/auth/start-refister&quot;, &#123;email: form.email, // 用户的邮箱code: form.code   // 验证码&#125;, () =&gt; &#123;          // 请求成功后增加active值active.value++;&#125;);&#125; else &#123;          // 如果表单无效，显示警告信息ElMessage.warning(&quot;请填写邮箱和表单&quot;);&#125;&#125;);&#125;</code></pre><p>注意validate是ELement提供的回调函数，isvailid是他提供的他只真或者假的，在这里注意看它的  active.value++;</p><h2 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">import &#123;ElMessage&#125; from &quot;element-plus&quot;;</span><br><span class="line"></span><br><span class="line">const defaultError=()=&gt;ElMessage.error(&quot;发生了一些错误，请联系管理员&quot;)</span><br><span class="line"></span><br><span class="line">const defaultFailure=(message)=&gt;ElMessage.warning(message)</span><br><span class="line"></span><br><span class="line">function post(url,data,success,failure=defaultFailure,error=defaultError)&#123;</span><br><span class="line">        axios.post(url,data,&#123;</span><br><span class="line">            headers:&#123;</span><br><span class="line">                &#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            withCredentials:true</span><br><span class="line">        &#125;).then((&#123;data&#125;)=&gt;&#123;</span><br><span class="line">            if(data.success)</span><br><span class="line">                success(data.message,data.status)</span><br><span class="line">            else</span><br><span class="line">                failure(data.message,data.status)</span><br><span class="line"></span><br><span class="line">        &#125;).catch(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我来讲一讲</p><p>headers: { ‘Content-Type’: ‘application&#x2F;x-www-form-urlencoded’ }</p><p>这行代码设置了 HTTP 请求的头部信息，具体来说是 Content-Type 头部。</p><p>Content-Type: 这个头部告诉服务器请求中的数据是什么类型。在这里，application&#x2F;x-www-form-urlencoded 表示数据将以键值对的形式编码，类似于 URL 参数。这种编码方式常用于表单提交。<br>作用: 服务器根据 Content-Type 头部来解析请求体中的数据。如果不设置这个头部，服务器可能无法正确解析数据，导致请求失败。</p><p><strong>当我们使用键值对向后端发数据的时候</strong></p><pre><code>假设你有以下数据需要发送：JSON&#123;&quot;name&quot;: &quot;John Doe&quot;,&quot;age&quot;: 30,&quot;city&quot;: &quot;New York&quot;&#125;AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.使用 application/x-www-form-urlencoded 编码后，这些数据会变成：name=John+Doe&amp;age=30&amp;city=New+York</code></pre><p><strong>如果想向后端发送json数据</strong></p><figure class="highlight plaintext"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Content-Type&#x27;: &#x27;application/json&#x27; // 设置请求头，指定内容类型为 application/json</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是模仿数据发送的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userData = &#123;</span><br><span class="line">    username: &quot;john_doe&quot;,</span><br><span class="line">    password: &quot;securepassword&quot;,</span><br><span class="line">    email: &quot;john@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器接受</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/register&quot;)</span><br><span class="line">    public ResponseEntity&lt;String&gt; registerUser(@RequestBody User user) &#123;</span><br><span class="line">        // 处理注册逻辑</span><br><span class="line">        return ResponseEntity.ok(&quot;User registered successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的作用<br><code>@RequestBody 注解用于将请求体中的 JSON 数据映射到 User 对象。</code></p><p>看到这个地方心里就啥就明白了吧！</p><p><strong>withCredentials: true</strong></p><p>   这行代码设置了跨域请求时是否携带凭证（如 cookies、HTTP 认证信息等）。</p><p>withCredentials: 这是一个布尔值选项，表示是否允许跨域请求携带凭证</p><p><strong>在继续看then</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.then((&#123;data&#125;)=&gt;&#123;</span><br><span class="line">            if(data.success)</span><br><span class="line">                success(data.message,data.status)</span><br><span class="line">            else</span><br><span class="line">                failure(data.message,data.status)</span><br><span class="line"></span><br><span class="line">        &#125;).catch(error)</span><br></pre></td></tr></table></figure><p>then,代表，请求成功之后的调用段代码 then(({ data }) &#x3D;&gt; { … }) 部分使用了解构赋值，将响应对象中的 data 属性提取出来，直接使用 data 变量，而不需要写成 response.data</p><p>双括号是then也需要个回调函数作为参数，而这个回调函数本身也需要调用。第一个括号是调用 then 方法，第二个括号是定义并调用回调函数</p><p><strong>catch</strong><br>catch 方法接收一个回调函数，该函数会在请求失败时执行。<br>回调函数的参数是错误对象 error。<br>在这里，catch 方法调用了 error 函数（即 defaultError），显示错误消息</p><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p>如同上一小节，这节将讲一讲跨域请求与<br><strong>withCredentials: true</strong></p><p>这行代码设置了跨域请求时是否携带凭证（如 cookies、HTTP 认证信息等）。</p><p>withCredentials: 这是一个布尔值选项，表示是否允许跨域请求携带凭证</p><p><code>withCredentials: true 和 corsConfiguration.setAllowCredentials(true)</code></p><p>前端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前端</span><br><span class="line">withCredentials: true: 这是在前端配置中使用的，告诉浏览器在跨域请求时携带凭证（如 cookies）。</span><br><span class="line">JavaScript</span><br><span class="line"></span><br><span class="line">axios.post(url, data, &#123;</span><br><span class="line">withCredentials: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corsConfiguration.setAllowCredentials(true): 这是在后端配置中使用的，告诉服务器允许跨域请求携带凭证。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这两者结合使用时，前端会发送凭证，后端会接受这些凭证，从而实现跨域请求时的身份验证。</strong></p><p> @CrossOrigin</p><p>@CrossOrigin: 这是一个注解，用于配置允许哪些域可以进行跨域请求。可以应用于控制器类或方法上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins = &quot;http://example.com&quot;)</span><br><span class="line">@GetMapping(&quot;/data&quot;)</span><br><span class="line">public ResponseEntity&lt;String&gt; getData() &#123;</span><br><span class="line">return ResponseEntity.ok(&quot;Some data&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用:</p><p>这个注解主要用于指定允许的跨域请求来源、方法等。它可以细粒度地控制哪些请求被允许跨域访问。</p><p>区别总结<br>配置范围:</p><figure class="highlight plaintext"><figcaption><span>和 setAllowCredentials 主要用于处理跨域请求时的凭证携带问题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin 用于配置允许的跨域请求来源、方法等，提供更全面的跨域控制。</span><br></pre></td></tr></table></figure><p>使用场景:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果你需要处理跨域请求时的身份验证问题，使用 withCredentials 和 setAllowCredentials。</span><br><span class="line">如果你需要配置哪些域可以进行跨域请求，使用 @CrossOrigin。</span><br></pre></td></tr></table></figure><p>灵活性:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin 可以在控制器或方法级别进行配置，灵活性更高。</span><br><span class="line">withCredentials 和 setAllowCredentials 主要用于全局配置跨域请求的凭证携带。</span><br></pre></td></tr></table></figure><h2 id="路由管理和全局守卫"><a href="#路由管理和全局守卫" class="headerlink" title="路由管理和全局守卫"></a>路由管理和全局守卫</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// 导入 Vue Router 所需的模块</span><br><span class="line">import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;</span><br><span class="line">// 从指定路径导入 store</span><br><span class="line">import &#123; useStore &#125; from &quot;@/stores/counter.js&quot;;</span><br><span class="line"></span><br><span class="line">// 创建一个新的路由实例</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  // 使用 HTML5 历史模式进行导航</span><br><span class="line">  history: createWebHistory(import.meta.env.BASE_URL),</span><br><span class="line">  // 定义应用的路由</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      // 欢迎视图的根路径</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      name: &#x27;welcome&#x27;,</span><br><span class="line">      // 懒加载欢迎视图组件</span><br><span class="line">      component: () =&gt; import(&#x27;@/views/weclcome.vue&#x27;),</span><br><span class="line">      // 定义欢迎视图的子路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          // 登录页面的默认子路由</span><br><span class="line">          path: &#x27;&#x27;,</span><br><span class="line">          name: &#x27;welcome-login&#x27;,</span><br><span class="line">          // 懒加载登录页面组件</span><br><span class="line">          component: () =&gt; import(&#x27;@/c*************.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // 注册页面的路由</span><br><span class="line">          path: &#x27;/re*****r&#x27;,</span><br><span class="line">          name: &#x27;welcome-RegisterPage&#x27;,</span><br><span class="line">          // 懒加载注册页面组件</span><br><span class="line">          component: () =&gt; import(&#x27;@/c***************e.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // 忘记密码页面的路由</span><br><span class="line">          path: &#x27;/fo***t&#x27;,</span><br><span class="line">          name: &#x27;welcome-forget&#x27;,</span><br><span class="line">          // 懒加载忘记密码页面组件</span><br><span class="line">          component: () =&gt; import(&#x27;@/*****************e.vue&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      // 主索引视图的路由</span><br><span class="line">      path: &#x27;/i***x&#x27;,</span><br><span class="line">      name: &#x27;index&#x27;,</span><br><span class="line">      // 懒加载索引视图组件</span><br><span class="line">      component: () =&gt; import(&#x27;@/v*************vue&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 定义全局导航守卫</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // 获取 store 实例</span><br><span class="line">  const store = useStore()</span><br><span class="line">  // 如果用户已认证且尝试访问欢迎路由，则重定向到索引页面</span><br><span class="line">  if (store.auth.user != null &amp;&amp; to.name.startsWith(&#x27;welcome&#x27;)) &#123;</span><br><span class="line">    next(&#x27;/index&#x27;)</span><br><span class="line">  // 如果用户未认证且尝试访问索引路由，则重定向到欢迎页面</span><br><span class="line">  &#125; else if (store.auth.user == null &amp;&amp; to.fullPath.startsWith(&#x27;/index&#x27;)) &#123;</span><br><span class="line">    next(&#x27;/&#x27;)</span><br><span class="line">  // 如果路由不匹配任何定义的路由，则重定向到欢迎页面</span><br><span class="line">  &#125; else if (to.matched.length === 0) &#123;</span><br><span class="line">    next(&#x27;/&#x27;)</span><br><span class="line">  // 否则，继续导航到下一个路由</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 导出路由实例以供应用使用</span><br><span class="line">export default router</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>导入：导入 vue-router 中的必要模块和 @&#x2F;stores&#x2F;counter.js 中的 store。</p><p>创建路由：使用 createRouter 创建一个新的路由实例，使用 HTML5 历史模式和定义的路由。</p><p>定义路由：</p><p>根路径 (&#x2F;) 关联到 welcome 视图，该视图有子路由用于登录、注册和忘记密码页面。</p><p>&#x2F;index 路径关联到主 index 视图。</p><p>导航守卫：</p><p>在每次路由变化之前，beforeEach 守卫会检查用户的认证状态。</p><p>如果用户已认证且尝试访问欢迎路由，则重定向到索引页面。</p><p>如果用户未认证且尝试访问索引页面，则重定向到欢迎页面。</p><p>如果路由不匹配任何定义的路由，则重定向到欢迎页面。</p><p>否则，继续导航到下一个路由。</p><p>导出：导出路由实例以供应用使用。</p><h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">路由管理</span><br><span class="line">路由管理是指在单页应用（SPA）中，通过定义不同的路由来管理页面的导航。Vue Router 是 Vue.js 官方的路由管理器，它允许我们在 Vue 应用中轻松地定义和管理路由。</span><br><span class="line"></span><br><span class="line">基本概念</span><br><span class="line">路由：路由是 URL 与组件之间的映射关系。每个路由都包含一个路径和一个组件，当用户访问该路径时，Vue Router 会渲染对应的组件。</span><br><span class="line">路由表：路由表是一个数组，包含所有路由的定义。每个路由对象通常包含 path 和 component 属性。</span><br><span class="line">嵌套路由：嵌套路由允许我们在一个路由中定义子路由，从而实现多级导航结构。</span><br></pre></td></tr></table></figure><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全局守卫</span><br><span class="line">全局守卫是指在路由变化时执行的钩子函数。Vue Router 提供了三种全局守卫：</span><br><span class="line"></span><br><span class="line">beforeEach：在每次路由变化前执行。</span><br><span class="line">beforeResolve：在组件内守卫和异步路由组件被解析之后执行。</span><br><span class="line">afterEach：在每次路由变化后执行。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeEach：</span><br><span class="line">    to：即将进入的路由对象。</span><br><span class="line">    from：当前导航正要离开的路由对象。</span><br><span class="line">    next：必须调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</span><br><span class="line">    在 beforeEach 守卫中，我们可以添加逻辑来检查用户的权限或状态。例如，检查用户是否已登录，如果未登录则重定向到登录页面。</span><br><span class="line">afterEach：</span><br><span class="line">    to：即将进入的路由对象。</span><br><span class="line">    from：当前导航正要离开的路由对象。</span><br><span class="line">    在 afterEach 守卫中，我们可以添加逻辑来执行一些操作，例如记录页面访问日志或更新页面标题。</span><br></pre></td></tr></table></figure><h3 id="stores"><a href="#stores" class="headerlink" title="stores"></a>stores</h3><p>是用于管理应用状态的地方。它们提供了一种集中管理和共享状态的方式，使得不同组件之间可以方便地访问和修改状态。Pinia 是 Vue 的状态管理库之一，它提供了简单且强大的 API 来定义和使用 stores。<br>如上一个所示，userstore的创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const useStore = defineStore(&#x27;store&#x27;, () =&gt; &#123;</span><br><span class="line">const auth = reactive(&#123;</span><br><span class="line">  user:null</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  return &#123; auth&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要功能</span><br><span class="line">集中管理状态：</span><br><span class="line">stores 将应用的状态集中在一个地方，方便管理和维护。</span><br><span class="line">例如，用户的认证状态、应用的设置、购物车的内容等都可以存储在 stores 中。</span><br><span class="line">共享状态：</span><br><span class="line">通过 stores，不同的组件可以共享同一个状态。</span><br><span class="line">例如，用户登录后，多个组件都需要知道用户的登录状态，这时可以通过 stores 来实现状态共享。</span><br><span class="line">响应式状态：</span><br><span class="line">stores 中的状态是响应式的，当状态发生变化时，依赖该状态的组件会自动更新。</span><br><span class="line">例如，当购物车中的商品数量发生变化时，显示购物车内容的组件会自动更新。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>在使用main.js里面的作用</p><p>整体作用是创建并配置一个 Vue 应用，使用 Pinia 进行状态管理，使用 Vue Router 进行导航，并通过 axios 进行 HTTP 请求。最后，将应用挂载到指定的 DOM 元素上进行渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                            // 从 Vue 导入 createApp 函数</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">                             // 从 Pinia 导入 createPinia 函数</span><br><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">                              // 导入主应用组件</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">                            // 导入路由配置</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">                                // 导入 Element Plus 的样式文件</span><br><span class="line">import &#x27;element-plus/dist/index.css&#x27;</span><br><span class="line">                                // 导入 axios 库</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line"></span><br><span class="line">                             // 创建一个 Vue 应用实例</span><br><span class="line">const app = createApp(App)</span><br><span class="line">                                 // 设置 axios 的默认基础 URL</span><br><span class="line">axios.defaults.baseURL = &#x27;http://localhost:8091&#x27;</span><br><span class="line"></span><br><span class="line">                                    // 使用 Pinia 作为状态管理库</span><br><span class="line">app.use(createPinia())</span><br><span class="line">                            // 使用路由配置</span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line">                            // 挂载应用到指定的 DOM 元素上</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，上面挂载默认界面是App.Vue</p><p>拿着本实战来说APP.vue为根目录<br>他里面就存放一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>&lt;router-view&gt; </code>是一个占位符，表示路由匹配的组件将会在这里渲染。这样，当你导航到不同的路由时，<br>匹配的组件会在 App.vue 中的 <code>&lt;router-view&gt;</code>里面</p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>components 目录通常包含应用中可复用的、独立的 UI 组件。这些组件可以在多个地方使用，并且通常是较小的、功能单一的组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可复用性：这些组件可以在多个视图或其他组件中使用。</span><br><span class="line">独立性：每个组件通常只负责一个特定的功能或 UI 部分。</span><br><span class="line">粒度较小：组件通常是较小的 UI 单元，例如按钮、输入框、卡片等。</span><br></pre></td></tr></table></figure><p>这个很好理解，就是 子路由</p><h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>目录通常包含应用中的页面级组件。这些组件通常对应于路由，并且是较大的、包含多个子组件的组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">页面级别：这些组件通常对应于应用中的一个完整页面。</span><br><span class="line">包含子组件：视图组件通常包含多个子组件，组合成一个完整的页面。</span><br><span class="line">与路由关联：每个视图组件通常对应一个路由路径</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类，接口，构造方法详解</title>
      <link href="/2024/03/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/03/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h1><p>在 Java 语言中使用 abstract class 来定义抽象类，<br>抽象类不能被实例化，抽象类必须被继承，才能被使用。<br>一个类只能继承一个抽象类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String address, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructing an Employee&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Employee computePay&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mailCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mailing a check to &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + address + <span class="string">&quot; &quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String newAddress)</span> &#123;</span><br><span class="line">        address = newAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* 以下是不允许的，会引发错误 */</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;George W.&quot;</span>, <span class="string">&quot;Houston, TX&quot;</span>, <span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n Call mailCheck using Employee reference--&quot;</span>);</span><br><span class="line">        e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然它会报错，这就是抽象类，不能被实例化的例子。但是注意如果实例化继承它的类是可以用这个抽象类所有的方法的</p><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a><strong>继承抽象类</strong></h2><p>继承抽象类，用extend  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> salary; <span class="comment">//Annual salary</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Salary</span><span class="params">(String name, String address, <span class="type">int</span> number, <span class="type">double</span></span></span><br><span class="line"><span class="params">      salary)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">super</span>(name, address, number);</span><br><span class="line">       setSalary(salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mailCheck</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Within mailCheck of Salary class &quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;Mailing check to &quot;</span> + getName()</span><br><span class="line">       + <span class="string">&quot; with salary &quot;</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> newSalary)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(newSalary &gt;= <span class="number">0.0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          salary = newSalary;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Computing salary pay for &quot;</span> + getName());</span><br><span class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。<br>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Salary</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="string">&quot;Mohd Mohtashim&quot;</span>, <span class="string">&quot;Ambehta, UP&quot;</span>, <span class="number">3</span>, <span class="number">3600.00</span>);</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="string">&quot;John Adams&quot;</span>, <span class="string">&quot;Boston, MA&quot;</span>, <span class="number">2</span>, <span class="number">2400.00</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;Call mailCheck using Salary reference --&quot;</span>);</span><br><span class="line">      s.mailCheck();</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;\n Call mailCheck using Employee reference--&quot;</span>);</span><br><span class="line">      e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造方法在抽象类的应用"><a href="#构造方法在抽象类的应用" class="headerlink" title="构造方法在抽象类的应用"></a>构造方法在抽象类的应用</h3><p>接下来让我详细给你讲一讲，首先实例化Salary并命名为s注意这个地方传了四个参数这个地方用的就是构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Salary</span> <span class="params">(String name, String address, <span class="type">int</span> number, <span class="type">double</span></span></span><br><span class="line"><span class="params">     salary)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">super</span>(name, address, number);</span><br><span class="line">      setSalary(salary);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意 super(name, address, number); 是从父类继承来的。而setSalary(salary);是设置Salary的值。</p><h2 id="抽像方法"><a href="#抽像方法" class="headerlink" title="抽像方法"></a><strong>抽像方法</strong></h2><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意抽象类中有public abstract double computePay();这个就是抽象方法，它只有(),没有{}<br><strong>注意如果一个类包含抽象方法，那么该类必须是抽象类。<br>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</strong><br>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，<br>必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><h2 id="抽象总结"><a href="#抽象总结" class="headerlink" title="抽象总结"></a><strong>抽象总结</strong></h2><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h1><p>接口在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明<br>接口并不是类，类描述对象的属性和方法。接口则包含类要实现的方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。  </p><h2 id="接口与类的异同点"><a href="#接口与类的异同点" class="headerlink" title="接口与类的异同点"></a>接口与类的异同点</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><pre><code>一个接口可以有多个方法。接口文件保存在 .java 结尾的文件中，文件名使用接口名。接口的字节码文件保存在 .class 结尾的文件中。接口相应的字节码文件必须在与包名称相匹配的目录结构中</code></pre><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><pre><code>    接口不能被实例化    接口没有构造方法    接口中的所有方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。    接口不是要被继承而是要被实现    接口支持多继承</code></pre><h2 id="接口与抽象类的异同点"><a href="#接口与抽象类的异同点" class="headerlink" title="接口与抽象类的异同点"></a>接口与抽象类的异同点</h2><p>抽象类可以有抽象方法体，就是方法的具体功能，而接口中的方法不能<br>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。<br>一个类只能继承一个抽象类，而一个类却可以实现多个接口</p><h2 id="接口举例"><a href="#接口举例" class="headerlink" title="接口举例"></a>接口举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NameOfInterface</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//任何类型 final, static 字段</span></span><br><span class="line">   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。接口中的方法都是公有的。</code></pre><p>如下图代码 抽象方法的abstract被隐藏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>接口要实现它里面的所有方法否则，类必须声明为抽象的类。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面<br>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MammalInt</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">noOfLegs</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">MammalInt</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MammalInt</span>();</span><br><span class="line">m.eat();</span><br><span class="line">m.travel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写接口中声明的方法时，需要注意以下规则"><a href="#重写接口中声明的方法时，需要注意以下规则" class="headerlink" title="重写接口中声明的方法时，需要注意以下规则"></a>重写接口中声明的方法时，需要注意以下规则</h3><p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。<br>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。<br>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p><h3 id="在实现接口的时候，也要注意一些规则"><a href="#在实现接口的时候，也要注意一些规则" class="headerlink" title="在实现接口的时候，也要注意一些规则"></a>在实现接口的时候，也要注意一些规则</h3><p>一个类可以同时实现多个接口。<br>一个类只能继承一个类，但是能实现多个接口。<br>一个接口能继承另一个接口，这和类之间的继承比较相似。</p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>在Java中，类的多继承是不合法，但接口允许多继承。</p><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hockey</span> <span class="keyword">extends</span> <span class="title class_">Sports</span>, Event</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="构造方法的特点"><a href="#构造方法的特点" class="headerlink" title="构造方法的特点"></a>构造方法的特点</h2><pre><code>构造方法的名称必须与类名完全相同。构造方法没有返回类型，包括void。构造方法在创建对象时被调用，用于初始化对象。如果没有显式定义构造方法，默认会有一个无参构造方法。你可以重载构造方法，即定义多个具有不同参数列表的构造方法</code></pre><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象并调用构造方法进行初始化</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 使用无参构造方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>); <span class="comment">// 使用带参数的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法总的来说"><a href="#构造方法总的来说" class="headerlink" title="构造方法总的来说"></a>构造方法总的来说</h2><p>构造方法的主要作用是初始化对象的状态，也就是为对象的实例变量赋初值。<br>构造方法可以被子类继承和调用，用于初始化对象的状态。当一个类继承自抽象类时，在创建对象实例时会调用父类的构造方法来初始化父类的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白安装git和Hexo</title>
      <link href="/2024/03/21/%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85git%E5%92%8CHexo/"/>
      <url>/2024/03/21/%E5%B0%8F%E7%99%BD%E5%AE%89%E8%A3%85git%E5%92%8CHexo/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h1><p>你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>比如我的博客文件都存放在D:\Study\MyBlog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。</p><p>定位到该目录下，输入<a name="_hlk161739177"></a>npm install -g hexo-cli安装Hexo。               </p><h2 id="为什么要在这个文件夹下面来创建hexo"><a href="#为什么要在这个文件夹下面来创建hexo" class="headerlink" title="为什么要在这个文件夹下面来创建hexo"></a>为什么要在这个文件夹下面来创建hexo</h2><p><strong>全局安装只是确保你可以在任何地方使用 Hexo 的命令行界面，但是在实际使用 Hexo 时，你仍然需要在你的博客文件夹中进行相关操作。</strong></p><p><strong>定位到文件夹下的目的是为了告诉 Hexo 在哪个文件夹中生成博客网站。Hexo 是基于文件夹的静态网站生成器，它会根据当前所在的文件夹中的配置文件和内容来生成博客网站。因此，为了让 Hexo 正确地生成你的博客，你需要先进入存放博客文件的文件夹，在该文件夹中执行 Hexo 相关的命令，从而确保博客内容可被正确生成和发布。</strong></p><p><strong>总结起来，全局安装 Hexo 的命令行界面只是确保你可以在全局的任何地方使用 Hexo 命令，而定位到文件夹下是为了在指定的博客文件夹中进行具体的 Hexo 操作，以生成和管理博客网站。</strong></p><h2 id="npm-install-g-hexo-cli安装Hexo报错。"><a href="#npm-install-g-hexo-cli安装Hexo报错。" class="headerlink" title="npm install -g hexo-cli安装Hexo报错。"></a><strong>npm install -g hexo-cli安装Hexo报错。</strong></h2><p><strong>$ npm install -g hexo-cli</strong></p><p><strong>npm ERR! code EPERM</strong></p><p><strong>npm ERR! syscall mkdir</strong></p><p><strong>npm ERR! path D:\nodejs\node_cache\_cacache</strong></p><p><strong>npm ERR! errno -4048</strong></p><p><strong>npm ERR! Error: EPERM: operation not permitted, mkdir ‘D:\nodejs\node_cache\_cacache’</strong></p><p><strong>npm ERR!  [Error: EPERM: operation not permitted, mkdir ‘D:\nodejs\node_cache\_cacache’] {</strong></p><p><strong>npm ERR!   errno: -4048,</strong></p><p><strong>npm ERR!   code: ‘EPERM’,</strong></p><p><strong>npm ERR!   syscall: ‘mkdir’,</strong></p><p><strong>npm ERR!   path: ‘D:\nodejs\<a name="_hlk161739480"></a>node_cache\_cacache’</strong></p><p><strong>npm ERR! }</strong></p><p><strong>npm ERR!</strong></p><p><strong>npm ERR! The operation was rejected by your operating system.</strong></p><p><strong>npm ERR! It’s possible that the file was already in use (by a text editor or antivirus),</strong></p><p><strong>npm ERR! or that you lack permissions to access it.</strong></p><p><strong>npm ERR!</strong></p><p><strong>npm ERR! If you believe this might be a permissions issue, please double-check the</strong></p><p><strong>npm ERR! permissions of the file and its containing directories, or try running</strong></p><p><strong>npm ERR! the command again as root&#x2F;Administrator.</strong></p><p><strong>npm ERR! Log files were not written due to an error writing to the directory: D:\nodejs\node_cache\_logs</strong></p><p>npm ERR! You can rerun the command with <code>--loglevel=verbose</code> to see the logs in your terminal</p><p><a name="_hlk161739652"></a></p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p><strong>意思是权限不够</strong></p><p>这个错误通常是由于权限问题或者其他进程正在使用相关文件所导致的。有几种可能的解决方法：</p><p>1. 以管理员身份运行命令提示符：右键点击命令提示符符号，然后选择“以管理员身份运行”选项。接下来再尝试运行 <code>npm install -g hexo-cli</code> 命令看是否能够解决问题。</p><p>2. 使用 <code>sudo</code> 运行命令（仅适用于 macOS 和 Linux 用户）：在命令前添加 <code>sudo</code>，即 <code>sudo npm install -g hexo-cli</code>。这将使用管理员权限来运行命令。</p><p>3. 检查文件权限：确保你具有对所涉及的目录和文件的写入权限，以及没有其他进程正在使用文件。特别是要注意杀毒软件或防火墙等安全软件是否导致了文件被锁定。</p><p>请尝试这些方法来解决权限问题，并让我知道是否成功。如果问题仍然存在，请提供更多详细信息，以便我能够提供更准确的建议。</p><h3 id="解决方法及结果"><a href="#解决方法及结果" class="headerlink" title="解决方法及结果"></a><strong>解决方法及结果</strong></h3><p>修改了node_cache文件夹的权限成功部署Hexo</p><p><strong>$ npm install -g hexo-cli</strong></p><p><strong>added 54 packages in 7s</strong></p><p><strong>15 packages are looking for funding</strong></p><p><code>  </code><strong>run <code>npm fund</code> for details</strong></p><p><strong>npm notice</strong></p><p><strong>npm notice New minor version of npm available! 10.2.4 -&gt; 10.5.0</strong></p><p><strong>npm notice Changelog: <a href="https://github.com/npm/cli/releases/tag/v10.5.0">https://github.com/npm/cli/releases/tag/v10.5.0</a></strong></p><p><strong>npm notice Run <code>npm install -g npm@10.5.0</code> to update!</strong></p><p><strong>npm notice</strong></p><p>**</p><h3 id="输入-hexo-v找不到"><a href="#输入-hexo-v找不到" class="headerlink" title="输入 hexo -v找不到"></a><strong>输入 hexo -v找不到</strong></h3><p>$ hexo -v</p><p>bash: hexo: command not found</p><p>发现可能是npm的环境变量未设置，我也是服了</p><h3 id="成功配置找到hexo"><a href="#成功配置找到hexo" class="headerlink" title="成功配置找到hexo"></a><strong>成功配置找到hexo</strong></h3><p>原因我在node.js中修改了配置文件并没有在环境变量中设置它</p><h1 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a><strong>初始化hexo</strong></h1><p>$ hexo init</p><p>INFO  Cloning hexo-starter <a href="https://github.com/hexojs/hexo-starter.git">https://github.com/hexojs/hexo-starter.git</a></p><p>INFO  Install dependencies</p><p>INFO  Start blogging with Hexo!</p><h1 id="hexo-g-生成静态文件-hexo-s启动服务端"><a href="#hexo-g-生成静态文件-hexo-s启动服务端" class="headerlink" title="hexo-g 生成静态文件 hexo-s启动服务端"></a><strong>hexo-g 生成静态文件 hexo-s启动服务端</strong></h1><p>hexo g其中的g代表generate生成静态文件</p><p>其中的hexo-s中service是服务端</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Git设置用户名和邮箱"><a href="#Git设置用户名和邮箱" class="headerlink" title="Git设置用户名和邮箱"></a><strong>Git设置用户名和邮箱</strong></h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h2><p>是为了在传输到githup上区分谁传的</p><p>langye@LAPTOP-D48FO80D MINGW64 &#x2F;d&#x2F;MyBlog</p><p><a name="_hlk161758030"></a>$ git config –global user.name “langye123”                                     </p><p>langye@LAPTOP-D48FO80D MINGW64 &#x2F;d&#x2F;MyBlog</p><p>$ git config –global user.email “<a href="mailto:&#50;&#52;&#x30;&#49;&#x30;&#x30;&#52;&#x37;&#55;&#54;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;">&#50;&#52;&#x30;&#49;&#x30;&#x30;&#52;&#x37;&#55;&#54;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;</a>“</p><p>langye@LAPTOP-D48FO80D MINGW64 &#x2F;d&#x2F;MyBlog</p><p>$ git config –global –list</p><p>user.name&#x3D;langye123</p><p>user.email&#x3D;<a href="mailto:&#50;&#x34;&#x30;&#49;&#x30;&#x30;&#52;&#x37;&#55;&#x36;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#50;&#x34;&#x30;&#49;&#x30;&#x30;&#52;&#x37;&#55;&#x36;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a></p><h2 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a><strong>详细讲解</strong></h2><p>$ git config –global user.name “langye123” 设置用户名</p><p>$ git config –global user.email “邮箱”</p><p>$ git config –global –list 展示是否成功</p><p>生成密钥</p><h1 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a><strong>生成密钥</strong></h1><p>$ ssh-keygen -t rsa -C “填邮箱地址”</p><p>&#96;</p><h2 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a><strong>两种方法</strong></h2><p>ssh-keygen -t rsa<code>和</code>ssh-keygen -t rsa -C “GitHub 邮箱”<code>之间的区别在于后者使用了</code>-C&#96; 选项来添加注释信息，以便将来能够识别该密钥是用于什么用途。</p><p>具体而言，<code>-C &quot;GitHub 邮箱&quot;</code> 中的邮件地址可以帮助你在管理多个密钥对时更容易地辨识每个密钥对所属的身份。这样可以让你清晰地知道每个密钥对是用于哪个服务或者哪个身份的认证。 </p><p>而如果只是使用<code>ssh-keygen -t rsa</code>，生成的密钥对就没有附带任何注释信息。这可能会使得在管理多个密钥对时变得不够清晰，因为无法通过注释来区分不同的密钥对所属的身份。</p><p><strong>用于提交的时候识别是不是本人的后续有一次报错因为把自己的邮箱隐藏了但是</strong></p><p><strong>$ ssh-keygen -t rsa -C “填邮箱地址”</strong></p><p><strong>填的还是它</strong></p><h1 id="看看是否连接到Githup"><a href="#看看是否连接到Githup" class="headerlink" title="看看是否连接到Githup"></a><strong>看看是否连接到Githup</strong></h1><p>$ ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a></p><p>The authenticity of host ‘github.com (20.205.243.166)’ can’t be established.</p><p>ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF&#x2F;zLDA0zPMSvHdkr4UvCOqU.</p><p>This key is not known by any other names.</p><p>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes</p><p>Warning: Permanently added ‘github.com’ (ED25519) to the list of known hosts.</p><p>Hi langye123! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>成功</p><h1 id="config-yml目录下修改配置"><a href="#config-yml目录下修改配置" class="headerlink" title="_config.yml目录下修改配置"></a><strong>_config.yml目录下修改配置</strong></h1><p><a name="_hlk161761804"></a>_config.yml目录下修改配置<br>deploy:<br><code>  </code>type: git<br><code>  </code>repo: <a href="https://github.com/langye123/langye123.github.io.git">https://github.com/langye123/langye123.github.io.git</a><br><code>  </code>branch: main</p><p>类型：git</p><p>仓库：<a href="https://github.com/langye123/langye123.github.io.git">https://github.com/langye123/langye123.github.io.git</a></p><p>分支：main</p><p>用http会造成登录github账号</p><p>改成这个了之前用Http报错。</p><p>deploy:<br><code>  </code>type: git<br><code>  </code>repo: <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>:langye123&#x2F;langye123.github.io.git<br><code>  </code>branch: main</p><p>这段文字中包含了关于 Git 仓库的信息，指明了仓库的类型是 Git，仓库地址为 <a href="https://github.com/langye123/langye123.github.io.git%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E6%94%AF%E6%98%AF">https://github.com/langye123/langye123.github.io.git，使用的分支是</a> main。如果需要进一步解释或有其他问题，请随时告诉我！</p><h1 id="安装-deploy-git。"><a href="#安装-deploy-git。" class="headerlink" title="安装 deploy-git。"></a><strong>安装 deploy-git。</strong></h1><p>安装 deploy-git ，也就是部署的命令，这样你才能用命令部署到 GitHub。</p><p>npm install hexo-deployer-git –save 这条命令是用来在 Hexo 静态网站生成器中安装并保存 hexo-deployer-git 插件的。</p><p>具体来说，hexo-deployer-git 是 Hexo 提供的一个部署插件，它允许你将生成的静态网站文件直接部署到 Git 仓库中，以便实现自动部署并发布网站的功能。一旦安装了这个插件，你就可以使用 Hexo 命令来将生成的静态网站文件快速地推送到指定的 Git 仓库中，方便地更新和管理你的网站内容。</p><p>成功</p><p>$ npm install hexo-deployer-git –save</p><p>added 9 packages, and audited 250 packages in 4s</p><p>29 packages are looking for funding</p><p>run <code>npm fund</code> for details</p><p>found 0 vulnerabilities</p><h1 id="部署快捷键"><a href="#部署快捷键" class="headerlink" title="部署快捷键"></a><strong>部署快捷键</strong></h1><p>exo clean 清除了你之前生成的东西，也可以不加。 </p><p>hexo generate 顾名思义，生成静态文章，可以用 hexo g 缩写 ，</p><p>hexo deploy 部署文章，可以用 hexo d 缩写</p><h1 id="npm-i-hexo-theme-butterfly"><a href="#npm-i-hexo-theme-butterfly" class="headerlink" title="$ npm i hexo-theme-butterfly"></a><strong>$ npm i hexo-theme-butterfly</strong></h1><p>用npm创建butterfly主题定制</p><p>$ npm i hexo-theme-butterfly</p><p>added 46 packages, and audited 296 packages in 11s</p><p>38 packages are looking for funding</p><p><code>  </code>run <code>npm fund</code> for details</p><p>found 0 vulnerabilities</p><h1 id="安装-pug-以及-stylus-的渲染器"><a href="#安装-pug-以及-stylus-的渲染器" class="headerlink" title="安装 pug 以及 stylus 的渲染器"></a><strong>安装 pug 以及 stylus 的渲染器</strong></h1><p>npm install hexo-renderer-pug hexo-renderer-stylus –save</p><p>。</p><h2 id="为啥安装它"><a href="#为啥安装它" class="headerlink" title="为啥安装它"></a><strong>为啥安装它</strong></h2><p>Pug 和 Stylus 是两种用于网页开发的预处理器，它们分别用于 HTML 模板和 CSS 样式表的渲染和生成。</p><p>1. Pug（之前被称为 Jade）：Pug 是一种基于缩进的模板引擎，用于简化 HTML 文档的编写。通过使用 Pug，您可以以更简洁、结构化的方式编写 HTML，并且可以嵌入 JavaScript 代码以及动态生成内容。Pug 文件需要经过渲染处理后才能生成最终的 HTML 页面。</p><p>2. Stylus：Stylus 是一种 CSS 预处理器，它允许您以更灵活、更简洁的方式编写 CSS 样式表。通过使用 Stylus，您可以使用变量、嵌套规则、混合（Mixin）等功能来提高 CSS 的可维护性和可读性。Stylus 文件也需要经过渲染处理后才能生成最终的 CSS 样式表。</p><p>在 Node.js 环境中，通常会使用相关的渲染器（如 <code>pug</code> 和 <code>stylus</code> 模块），来将 Pug 和 Stylus 文件渲染为最终的 HTML 和 CSS 文件，以便在网页中使用。这些渲染器会将 Pug 文件转换为标准的 HTML 文件，将 Stylus 文件转换为标准的 CSS 文件，从而方便在网站中使用这些预处理器所生成的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>你好github</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/19/hello-world/"/>
      <url>/2024/03/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
